<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>voxelfuse.simulation API documentation</title>
<meta name="description" content="Simulation Class â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>voxelfuse.simulation</code></h1>
</header>
<section id="section-intro">
<p>Simulation Class</p>
<p>Initialized from a VoxelModel object. Used to configure VoxCad and Voxelyze simulations.</p>
<hr>
<p>Copyright 2020 - Cole Brauer, Dan Aukes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Simulation Class

Initialized from a VoxelModel object. Used to configure VoxCad and Voxelyze simulations.

----

Copyright 2020 - Cole Brauer, Dan Aukes
&#34;&#34;&#34;

import os
import time
import subprocess
import multiprocessing
import numpy as np
from enum import Enum
from datetime import date
from typing import List, Tuple, TextIO
from tqdm import tqdm

from voxelfuse.voxel_model import VoxelModel, writeHeader, writeData, writeOpen, writeClos
from voxelfuse.primitives import empty

# Floating point error threshold for rounding to zero
FLOATING_ERROR = 0.0000000001

class Axis(Enum):
    &#34;&#34;&#34;
    Options for axes and planes.
    &#34;&#34;&#34;
    NONE = -1
    X = 0
    Y = 1
    Z = 2

class StopCondition(Enum):
    &#34;&#34;&#34;
    Options for simulation stop conditions.
    &#34;&#34;&#34;
    NONE = 0
    TIME_STEP = 1
    TIME_VALUE = 2
    TEMP_CYCLES = 3
    ENERGY_CONST = 4
    ENERGY_KFLOOR = 5
    MOTION_FLOOR = 6

class BCShape(Enum):
    &#34;&#34;&#34;
    Options for simulation boundary condition shapes.
    &#34;&#34;&#34;
    BOX = 0
    CYLINDER = 1
    SPHERE = 2

class _BCRegion:
    &#34;&#34;&#34;
    Internal boundary condition class.
    &#34;&#34;&#34;
    def __init__(self, name: str,
                 shape: BCShape,
                 position: Tuple[float, float, float],
                 size: Tuple[float, float, float],
                 radius: float,
                 fixed_dof: int,
                 force: Tuple[float, float, float],
                 displacement: Tuple[float, float, float],
                 torque: Tuple[float, float, float],
                 angular_displacement: Tuple[float, float, float]):

        self.name = name
        self.shape = shape
        self.position = position
        self.size = size
        self.radius = radius
        self.color = (0.6, 0.4, 0.4, 0.5)
        self.fixed_dof = fixed_dof
        self.force = force
        self.displacement = displacement
        self.torque = torque
        self.angular_displacement = angular_displacement

class _Sensor:
    &#34;&#34;&#34;
    Internal sensor class.
    &#34;&#34;&#34;
    def __init__(self, name: str, coords: Tuple[int, int, int], axis: Axis):
        self.name = name
        self.coords = coords
        self.axis = axis

class _Keyframe:
    &#34;&#34;&#34;
    Internal keyframe class.
    &#34;&#34;&#34;
    def __init__(self, time_value: float,
                 amplitude_pos: float,
                 amplitude_neg: float,
                 percent_pos: float,
                 period: float,
                 phase_offset: float,
                 temp_offset: float,
                 const_temp: bool,
                 square_wave: bool):

        self.time_value = time_value
        self.amplitude_pos = amplitude_pos
        self.amplitude_neg = amplitude_neg
        self.percent_pos = percent_pos
        self.period = period
        self.phase_offset = phase_offset
        self.temp_offset = temp_offset
        self.const_temp = const_temp
        self.square_wave = square_wave

class _TempControlGroup:
    &#34;&#34;&#34;
    Internal temperature control group class.
    &#34;&#34;&#34;
    def __init__(self, name: str, locations: List[Tuple[int, int, int]], keyframes: List[_Keyframe]):
        self.name = name
        self.locations = locations
        self.keyframes = keyframes

class _Disconnection:
    &#34;&#34;&#34;
    Internal disconnection class.
    &#34;&#34;&#34;
    def __init__(self, voxel_1: Tuple[int, int, int], voxel_2: Tuple[int, int, int]):
        self.vx1 = voxel_1
        self.vx2 = voxel_2

class Simulation:
    &#34;&#34;&#34;
    Simulation object that stores a VoxelModel and its associated simulation settings.
    &#34;&#34;&#34;

    def __init__(self, voxel_model, id_number: int = 0):
        &#34;&#34;&#34;
        Initialize a Simulation object with default settings.

        Models located at positive coordinate values will have their workspace
        size adjusted to maintain their position in the exported simulation.
        Models located at negative coordinate values will be shifted to the origin.

        Args:
            voxel_model: VoxelModel
        &#34;&#34;&#34;
        # Simulation ID and start date
        self.id = id_number
        self.date = date.today()

        # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
        self.__model = ((VoxelModel.copy(voxel_model).fitWorkspace()) | empty(num_materials=(voxel_model.materials.shape[1] - 1), resolution=voxel_model.resolution)).removeDuplicateMaterials()

        # Simulator ##############
        # Integration
        self.__integrator = 0
        self.__dtFraction = 1.0

        # Damping
        self.__dampingBond = 1.0 # (0-1) Bulk material damping
        self.__dampingEnvironment = 0.0001 # (0-0.1) Damping caused by fluid environment

        # Collisions
        self.__collisionEnable = False
        self.__collisionDamping = 1.0 # (0-2) Elastic vs inelastic conditions
        self.__collisionSystem = 3
        self.__collisionHorizon = 3

        # Features
        self.__blendingEnable = False
        self.__xMixRadius = 0
        self.__yMixRadius = 0
        self.__zMixRadius = 0
        self.__blendingModel = 0
        self.__polyExp = 1
        self.__volumeEffectsEnable = False
        self.__hydrogelModelEnable = False

        # Stop conditions
        self.__stopConditionType = StopCondition.NONE
        self.__stopConditionValue = 0.0

        # Equilibrium mode
        self.__equilibriumModeEnable = False

        # Environment ############
        # Boundary conditions
        self.__bcRegions = []

        # Gravity
        self.__gravityEnable = True
        self.__gravityValue = -9.81
        self.__floorEnable = True

        # Thermal
        self.__temperatureEnable = False
        self.__temperatureBaseValue = 25.0
        self.__temperatureVaryEnable = False
        self.__temperatureVaryAmplitude = 0.0
        self.__temperatureVaryPeriod = 0.0
        self.__temperatureVaryOffset = 0.0
        self.__growthAmplitude = 0.0

        # Sensors #######
        self.__sensors = []

        # Temperature Controls #######
        self.__currentTempControlGroup = 0
        self.__localTempControls = []

        # Disconnected Bonds #######
        self.__disconnections = []

        # Results ################
        self.results = []
        self.valueMap = np.zeros_like(voxel_model.voxels, dtype=np.float32)

    @classmethod
    def copy(cls, simulation):
        &#34;&#34;&#34;
        Create new Simulation object with the same settings as an existing Simulation object.

        Args:
            simulation: Simulation to copy
        
        Returns:
            Simulation
        &#34;&#34;&#34;
        # Create new simulation object and copy attribute values
        new_simulation = cls(simulation.__model)
        new_simulation.__dict__ = simulation.__dict__.copy()

        # Update ID and date
        new_simulation.id = simulation.id + 1
        new_simulation.date = date.today()

        # Make lists copies instead of references
        new_simulation.__bcRegions = simulation.__bcRegions.copy()
        new_simulation.__sensors = simulation.__sensors.copy()
        new_simulation.__localTempControls = simulation.__localTempControls.copy()
        new_simulation.__disconnections = simulation.__disconnections.copy()
        new_simulation.results = simulation.results.copy()
        new_simulation.valueMap = simulation.valueMap.copy()

        return new_simulation

    # Configure settings ##################################
    def setModel(self, voxel_model):
        &#34;&#34;&#34;
        Set the model for a simulation.

        Models located at positive coordinate values will have their workspace
        size adjusted to maintain their position in the exported simulation.
        Models located at negative coordinate values will be shifted to the origin.

        Args:
            voxel_model: VoxelModel
        
        Returns:
            None
        &#34;&#34;&#34;
        # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
        self.__model = ((VoxelModel.copy(voxel_model).fitWorkspace()) | empty(num_materials=(voxel_model.materials.shape[1] - 1))).removeDuplicateMaterials()

    def setDamping(self, bond: float = 1.0, environment: float = 0.0001):
        &#34;&#34;&#34;
        Set simulation damping parameters.

        Environment damping can be used to simulate fluid environments. 0 represents
        a vacuum and larger values represent a viscous fluid.

        Args:
            bond: Voxel bond damping (0-1)
            environment: Environment damping (0-0.1)
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__dampingBond = bond
        self.__dampingEnvironment = environment

    def setCollision(self, enable: bool = True, damping: float = 1.0):
        &#34;&#34;&#34;
        Set simulation collision parameters.

        A damping value of 0 represents completely elastic collisions and
        higher values represent inelastic collisions.

        Args:
            enable: Enable/disable collisions
            damping: Collision damping (0-2)
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__collisionEnable = enable
        self.__collisionDamping = damping

    def setHydrogelModel(self, enable: bool = True):
        &#34;&#34;&#34;
        Set hydrogel model parameters.

        Args:
            enable: Enable/disable hydrogel model
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__hydrogelModelEnable = enable

    def setStopCondition(self, condition: StopCondition = StopCondition.NONE, value: float = 0):
        &#34;&#34;&#34;
        Set simulation stop condition.

        Args:
            condition: Stop condition type, set using StopCondition class
            value: Stop condition value
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__stopConditionType = condition
        self.__stopConditionValue = value

    def setEquilibriumMode(self, enable: bool = True):
        &#34;&#34;&#34;
        Set simulation equilibrium mode.

        Args:
            enable: Enable/disable equilibrium mode
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__equilibriumModeEnable = enable

    def setGravity(self, enable: bool = True, value: float = -9.81, enable_floor: bool = True):
        &#34;&#34;&#34;
        Set simulation gravity parameters.

        Args:
            enable: Enable/disable gravity
            value: Acceleration due to gravity in m/sec^2
            enable_floor: Enable/disable ground plane
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__gravityEnable = enable
        self.__gravityValue = value
        self.__floorEnable = enable_floor

    def setFixedThermal(self, enable: bool = True, base_temp: float = 25.0, growth_amplitude: float = 0.0):
        &#34;&#34;&#34;
        Set a fixed environment temperature.

        Args:
            enable: Enable/disable temperature
            base_temp: Temperature in degrees C
            growth_amplitude: Set to 1 to enable expansion from base size
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__temperatureEnable = enable
        self.__temperatureBaseValue = base_temp
        self.__temperatureVaryEnable = False
        self.__growthAmplitude = growth_amplitude

    def setVaryingThermal(self, enable: bool = True, base_temp: float = 25.0, amplitude: float = 0.0, period: float = 1.0, offset: float = 0.0, growth_amplitude: float = 1.0):
        &#34;&#34;&#34;
        Set a varying environment temperature.


        Args:
            enable: Enable/disable temperature
            base_temp: Base temperature in degrees C
            amplitude: Temperature fluctuation amplitude
            period: Temperature fluctuation period
            offset: Temperature offset (not currently supported)
            growth_amplitude: Set to 1 to enable expansion from base size
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__temperatureEnable = enable
        self.__temperatureBaseValue = base_temp
        self.__temperatureVaryEnable = enable
        self.__temperatureVaryAmplitude = amplitude
        self.__temperatureVaryPeriod = period
        self.__temperatureVaryOffset = offset
        self.__growthAmplitude = growth_amplitude

    # Read settings ##################################
    def getModel(self):
        &#34;&#34;&#34;
        Get the simulation model.
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.__model

    def getVoxelDim(self):
        &#34;&#34;&#34;
        Get the side dimension of a voxel in mm.
        
        Returns:
            Float
        &#34;&#34;&#34;
        res = self.__model.resolution
        return (1.0/res) * 0.001

    def getDamping(self):
        &#34;&#34;&#34;
        Get simulation damping parameters.
        
        Returns:
            Voxel bond damping, Environment damping
        &#34;&#34;&#34;
        return self.__dampingBond, self.__dampingEnvironment

    def getCollision(self):
        &#34;&#34;&#34;
        Get simulation collision parameters.
        
        Returns:
            Enable/disable collisions, Collision damping
        &#34;&#34;&#34;
        return self.__collisionEnable, self.__collisionDamping

    def getHydrogelModel(self):
        &#34;&#34;&#34;
        Get hydrogel model parameters.
        
        Returns:
            Enable/disable hydrogel model
        &#34;&#34;&#34;
        return self.__hydrogelModelEnable

    def getStopCondition(self):
        &#34;&#34;&#34;
        Get simulation stop condition.
        
        Returns:
            Stop condition type, Stop condition value
        &#34;&#34;&#34;
        return self.__stopConditionType, self.__stopConditionValue

    def getEquilibriumMode(self):
        &#34;&#34;&#34;
        Get simulation equilibrium mode.
        
        Returns:
            Enable/disable equilibrium mode
        &#34;&#34;&#34;
        return self.__equilibriumModeEnable

    def getGravity(self):
        &#34;&#34;&#34;
        Get simulation gravity parameters.
        
        Returns:
            Enable/disable gravity, Acceleration due to gravity in m/sec^2, Enable/disable ground plane
        &#34;&#34;&#34;
        return self.__gravityEnable, self.__gravityValue, self.__floorEnable

    def getThermal(self):
        &#34;&#34;&#34;
        Get simulation temperature parameters.
        
        Returns:
            Enable/disable temperature, Base temperature in degrees C, Enable/disable temperature fluctuation, Temperature fluctuation amplitude, Temperature fluctuation period, Temperature offset
        &#34;&#34;&#34;
        return self.__temperatureEnable, self.__temperatureBaseValue, self.__temperatureVaryEnable, self.__temperatureVaryAmplitude, self.__temperatureVaryPeriod, self.__temperatureVaryOffset

    # Add forces, constraints, and sensors ##################################
    # Boundary condition sizes and positions are expressed as percentages of the overall model size
    #   radius is a percentage of the largest model dimension
    # Fixed DOF bits correspond to: Rz, Ry, Rx, Z, Y, X
    #   0: Free, force will be applied
    #   1: Fixed, displacement will be applied
    # Displacement is expressed in mm

    def clearBoundaryConditions(self):
        &#34;&#34;&#34;
        Remove all boundary conditions from a Simulation object.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__bcRegions = []
        # self.__bcVoxels = []

    # Default box boundary condition is a fixed constraint in the YZ plane
    def addBoundaryConditionVoxel(self, position: Tuple[int, int, int] = (0, 0, 0),
                                  fixed_dof: int = 0b111111,
                                  force: Tuple[float, float, float] = (0, 0, 0),
                                  displacement: Tuple[float, float, float] = (0, 0, 0),
                                  torque: Tuple[float, float, float] = (0, 0, 0),
                                  angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                  name: str = None):
        &#34;&#34;&#34;
        Add a boundary condition at a specific voxel.

        The fixed DOF value should be set as a 6-bit binary value (e.g. 0b111111) and the bits
        correspond to: Rz, Ry, Rx, Z, Y, X. If a bit is set to 0, the corresponding force/torque
        will be applied. If a bit is set to 1, the DOF will be fixed and the displacement will be
        applied.

        Args:
            position: Position in voxels
            fixed_dof: Fixed degrees of freedom
            force: Force vector in N
            displacement: Displacement vector in mm
            torque: Torque values in Nm
            angular_displacement: Angular displacement values in deg
            name: Boundary condition name
        
        Returns:
            None
        &#34;&#34;&#34;
        x = position[0] - self.__model.coords[0]
        y = position[1] - self.__model.coords[1]
        z = position[2] - self.__model.coords[2]

        x_len = int(self.__model.voxels.shape[0])
        y_len = int(self.__model.voxels.shape[1])
        z_len = int(self.__model.voxels.shape[2])

        pos = ((x+0.5)/x_len, (y+0.5)/y_len, (z+0.5)/z_len)
        radius = 0.49/x_len

        bc = _BCRegion(name, BCShape.SPHERE, pos, (0.0, 0.0, 0.0), radius, fixed_dof, force, displacement, torque, angular_displacement)
        self.__bcRegions.append(bc)

    # Default box boundary condition is a fixed constraint in the XY plane (bottom layer)
    def addBoundaryConditionBox(self, position: Tuple[float, float, float] = (0.0, 0.0, 0.0),
                                size: Tuple[float, float, float] = (1.0, 1.0, 0.01),
                                fixed_dof: int = 0b111111,
                                force: Tuple[float, float, float] = (0, 0, 0),
                                displacement: Tuple[float, float, float] = (0, 0, 0),
                                torque: Tuple[float, float, float] = (0, 0, 0),
                                angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                name: str = None):
        &#34;&#34;&#34;
        Add a box-shaped boundary condition.

        Boundary condition position and size are expressed as percentages of the
        overall model size. The fixed DOF value should be set as a 6-bit binary
        value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
        If a bit is set to 0, the corresponding force/torque will be applied. If
        a bit is set to 1, the DOF will be fixed and the displacement will be
        applied.

        Args:
            position: Box corner position (0-1)
            size: Box size (0-1)
            fixed_dof: Fixed degrees of freedom
            force: Force vector in N
            displacement: Displacement vector in mm
            torque: Torque values in Nm
            angular_displacement: Angular displacement values in deg
            name: Boundary condition name
        
        Returns:
            None
        &#34;&#34;&#34;
        bc = _BCRegion(name, BCShape.BOX, position, size, 0, fixed_dof, force, displacement, torque, angular_displacement)
        self.__bcRegions.append(bc)

    # Default sphere boundary condition is a fixed constraint centered in the model
    def addBoundaryConditionSphere(self, position: Tuple[float, float, float] = (0.5, 0.5, 0.5),
                                   radius: float = 0.05,
                                   fixed_dof: int = 0b111111,
                                   force: Tuple[float, float, float] = (0, 0, 0),
                                   displacement: Tuple[float, float, float] = (0, 0, 0),
                                   torque: Tuple[float, float, float] = (0, 0, 0),
                                   angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                   name: str = None):
        &#34;&#34;&#34;
        Add a spherical boundary condition.

        Boundary condition position and radius are expressed as percentages of the
        overall model size. The fixed DOF value should be set as a 6-bit binary
        value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
        If a bit is set to 0, the corresponding force/torque will be applied. If
        a bit is set to 1, the DOF will be fixed and the displacement will be
        applied.

        Args:
            position: Sphere center position (0-1)
            radius: Sphere radius (0-1)
            fixed_dof: Fixed degrees of freedom
            force: Force vector in N
            displacement: Displacement vector in mm
            torque: Torque values in Nm
            angular_displacement: Angular displacement values in deg
            name: Boundary condition name
        
        Returns:
            None
        &#34;&#34;&#34;
        bc = _BCRegion(name, BCShape.SPHERE, position, (0.0, 0.0, 0.0), radius, fixed_dof, force, displacement, torque, angular_displacement)
        self.__bcRegions.append(bc)

    # Default cylinder boundary condition is a fixed constraint centered in the model
    def addBoundaryConditionCylinder(self, position: Tuple[float, float, float] = (0.45, 0.5, 0.5), axis: Axis = Axis.X,
                                     height: float = 0.1,
                                     radius: float = 0.05,
                                     fixed_dof: int = 0b111111,
                                     force: Tuple[float, float, float] = (0, 0, 0),
                                     displacement: Tuple[float, float, float] = (0, 0, 0),
                                     torque: Tuple[float, float, float] = (0, 0, 0),
                                     angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                     name: str = None):
        &#34;&#34;&#34;
        Add a cylindrical boundary condition.

        Boundary condition position and size are expressed as percentages of the
        overall model size. The fixed DOF value should be set as a 6-bit binary
        value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
        If a bit is set to 0, the corresponding force/torque will be applied. If
        a bit is set to 1, the DOF will be fixed and the displacement will be
        applied.

        Args:
            position: Boundary condition origin position (0-1)
            axis: Cylinder axis (0-2)
            height: Cylinder height (0-1)
            radius: Cylinder radius (0-1)
            fixed_dof: Fixed degrees of freedom
            force: Force vector in N
            displacement: Displacement vector in mm
            torque: Torque values in Nm
            angular_displacement: Angular displacement values in deg
            name: Boundary condition name
        
        Returns:
            None
        &#34;&#34;&#34;
        size = [0.0, 0.0, 0.0]
        size[axis.value] = height
        bc = _BCRegion(name, BCShape.CYLINDER, position, (size[0], size[1], size[2]), radius, fixed_dof, force, displacement, torque, angular_displacement)
        self.__bcRegions.append(bc)

    def clearSensors(self):
        &#34;&#34;&#34;
        Remove all sensors from a Simulation object.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__sensors = []

    def addSensor(self, location: Tuple[int, int, int] = (0, 0, 0), axis: Axis = Axis.NONE, name: str = None): # TODO: Make Voxelyze use axis parameter
        &#34;&#34;&#34;
        Add a sensor to a voxel.

        Args:
            location: Sensor location in voxels
            axis: Sensor measurement axis
            name: Sensor name
        
        Returns:
            None
        &#34;&#34;&#34;
        x = location[0] - self.__model.coords[0]
        y = location[1] - self.__model.coords[1]
        z = location[2] - self.__model.coords[2]

        sensor = _Sensor(name, (x, y, z), axis)
        self.__sensors.append(sensor)

        if not self.__model.isOccupied((x, y, z)):
            print(&#39;WARNING: No material present at sensor voxel &#39; + str((x, y, z)))

    def clearDisconnections(self):
        &#34;&#34;&#34;
        Clear all disconnected voxel bonds.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__disconnections = []

    def addDisconnection(self, voxel_1: Tuple[int, int, int], voxel_2: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Specify a pair of voxels which should be disconnected

        Args:
            voxel_1: Coordinates in voxels
            voxel_2: Coordinates in voxels
        
        Returns:
            None
        &#34;&#34;&#34;
        dc = _Disconnection(voxel_1, voxel_2)
        self.__disconnections.append(dc)

    def addTempControlGroup(self, locations: List[Tuple[int, int, int]] = None, name: str = None):
        &#34;&#34;&#34;
        Add a new temperature control group and select it.

        Args:
            locations: Control element locations in voxels as a list of tuples
            name: Group name
        
        Returns:
            None
        &#34;&#34;&#34;
        # Enable temperature control
        self.__temperatureEnable = True
        self.__temperatureVaryEnable = True

        if locations is None:
            print(&#39;No locations provided - applying temperature control group to entire model&#39;)

            x_len = self.__model.voxels.shape[0]
            y_len = self.__model.voxels.shape[1]
            z_len = self.__model.voxels.shape[2]

            locations = []
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        locations.append((x, y, z))

        group = _TempControlGroup(name, locations, [])
        self.__localTempControls.append(group)
        self.__currentTempControlGroup = len(self.__localTempControls)-1

    def removeTempControlGroup(self, index: int = 0):
        &#34;&#34;&#34;
        Remove a temperature control group by index.

        Args:
            index: Temperature control group index
        
        Returns:
            Name of removed group
        &#34;&#34;&#34;
        group = self.__localTempControls.pop(index)
        self.__currentTempControlGroup = len(self.__localTempControls)-1
        return group.name

    def selectTempControlGroup(self, index: int = 0):
        &#34;&#34;&#34;
        Select which keyframe new temperature control elements should be added to.

        Args:
            index: Temperature control group index
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__currentTempControlGroup = index

    def clearTempControlGroups(self):
        &#34;&#34;&#34;
        Clear all temperature control groups.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__currentTempControlGroup = 0
        self.__localTempControls = []

    def cleanTempControlGroups(self):
        &#34;&#34;&#34;
        Remove invalid temperature control groups.

        Invalid groups have no keyframes, or have no target voxels.
        
        Returns:
            Number of groups removed
        &#34;&#34;&#34;
        removed_groups = []
        for g in range(len(self.__localTempControls)):
            g = g - len(removed_groups)
            group = self.__localTempControls[g]
            if len(group.keyframes) == 0 or len(group.locations) == 0:
                removed_groups.append(self.removeTempControlGroup(g))

        self.__currentTempControlGroup = len(self.__localTempControls)-1

        named_groups = []
        for n in removed_groups:
            if n is not None:
                named_groups.append(n)

        if len(removed_groups) == 0:
            pass
        elif len(named_groups) == 0:
            print(&#39;Removed &#39; + str(len(removed_groups)) + &#39; temperature control groups&#39;)
        else:
            print(&#39;Removed &#39; + str(len(removed_groups)) + &#39; temperature control groups, including: &#39; + str(named_groups))

        return len(removed_groups)

    def clearKeyframes(self):
        &#34;&#34;&#34;
        Remove all keyframes assigned to the current temperature control group.
        
        Returns:
            None
        &#34;&#34;&#34;
        g = self.__currentTempControlGroup
        self.__localTempControls[g].keyframes = []

    def addKeyframe(self, time_value: float = 0, amplitude_pos: float = 0, amplitude_neg: float = -1, percent_pos: float = 0.5,
                    period: float = 1.0, phase_offset: float = 0, temp_offset: float = 0, const_temp: bool = False, square_wave: bool = False):
        &#34;&#34;&#34;
        Add a keyframe to a temperature control group.

        Args:
            time_value: Time at which keyframe should take effect (sec)
            amplitude_pos: Control element positive temperature amplitude (deg C)
            amplitude_neg: Control element negative temperature amplitude (deg C)
            percent_pos: Percent of period spanned by positive temperature amplitude (0-1)
            period: Period of the control signal (sec)
            phase_offset: Control element phase offset for time-varying thermal (rad)
            temp_offset: Control element temperature offset for time-varying thermal (deg C)
            const_temp: Enable/disable setting a constant target temperature that respects heating/cooling rates
            square_wave: Enable/disable converting signal to a square wave (positive -&gt; a = amplitude1, negative -&gt; a = 0)
        
        Returns:
            None
        &#34;&#34;&#34;
        amplitude_pos = max(amplitude_pos, 0) # amplitude_pos must be positive

        if amplitude_neg &lt; 0: # If amplitude neg is not given (or not negative) use amplitude_pos instead
            amplitude_neg = amplitude_pos

        g = self.__currentTempControlGroup
        kf = _Keyframe(time_value, amplitude_pos, amplitude_neg, percent_pos, period, phase_offset, temp_offset, const_temp, square_wave)
        self.__localTempControls[g].keyframes.append(kf)

    def initializeTempMap(self):
        &#34;&#34;&#34;
        Initialize temperature control groups to which keyframes will be stored when using applyTempMap.
        
        Returns:
            None
        &#34;&#34;&#34;
        # Clear any existing temperature controls
        self.clearTempControlGroups()

        # Get map size
        x_len = self.__model.voxels.shape[0]
        y_len = self.__model.voxels.shape[1]
        z_len = self.__model.voxels.shape[2]

        # Generate empty control element for each voxel
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    self.addTempControlGroup([(x, y, z)])

    def applyTempMap(self, time_value, amp_pos_map, amp_neg_map=None, percent_pos_map=None, period_map=None,
                     phase_map=None, offset_map=None, const_temp_map=None, square_wave_map=None):
        &#34;&#34;&#34;
        Set the simulation temperature control elements based on a value maps of target temperature settings.

        This function relies on the temperature control groups being in a specific order. initializeTempMap should be called prior to running this function.

        Args:
            time_value: Time at which keyframe should take effect (sec)
            amp_pos_map: Array of target positive temperature amplitudes for each voxel (deg C)
            amp_neg_map: Array of target negative temperature amplitudes for each voxel (deg C)
            percent_pos_map: Array containing percent of period spanned by positive temperature amplitude for each voxel
            period_map: Array of signal periods for each voxel (sec)
            phase_map: Array of phase offsets for each voxel (rad)
            offset_map: Array of temperature offsets for each voxel (deg C)
            const_temp_map: Array of boolean values to enable/disable constant temperature mode
            square_wave_map: Array of boolean values to enable/disable square wave mode
        
        Returns:
            None
        &#34;&#34;&#34;
        # Get map size
        x_len = amp_pos_map.shape[0]
        y_len = amp_pos_map.shape[1]
        z_len = amp_pos_map.shape[2]

        # Generate the control element for each voxel
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    if abs(amp_pos_map[x, y, z]) &gt; FLOATING_ERROR or ((amp_neg_map is not None) and (abs(amp_neg_map[x, y, z]) &gt; FLOATING_ERROR)):  # If voxel is not empty
                        amplitude_pos = amp_pos_map[x, y, z]

                        if amp_neg_map is None:
                            amplitude_neg = amp_pos_map[x, y, z]
                        else:
                            amplitude_neg = amp_neg_map[x, y, z]

                        if percent_pos_map is None:
                            percent_pos = 0.5
                        else:
                            percent_pos = percent_pos_map[x, y, z]

                        if period_map is None:
                            period = 1.0
                        else:
                            period = period_map[x, y, z]

                        if phase_map is None:
                            phase_offset = 0
                        else:
                            phase_offset = phase_map[x, y, z]

                        if offset_map is None:
                            temp_offset = 0
                        else:
                            temp_offset = offset_map[x, y, z]

                        if const_temp_map is None:
                            const_temp = False
                        else:
                            const_temp = const_temp_map[x, y, z]

                        if square_wave_map is None:
                            square_wave = False
                        else:
                            square_wave = square_wave_map[x, y, z]

                        kf = _Keyframe(time_value, amplitude_pos, amplitude_neg, percent_pos, period, phase_offset, temp_offset, const_temp, square_wave)
                        g = z + y*z_len + x*y_len*z_len
                        self.__localTempControls[g].keyframes.append(kf)

    # Export simulation ##################################
    # Export simulation object to .vxa file for import into VoxCad or Voxelyze
    def saveVXA(self, filename: str, compression: bool = False):
        &#34;&#34;&#34;
        Save model data to a .vxa file

        The VoxCad simulation file format stores all the data contained in
        a .vxc file (geometry, material palette) plus the simulation setup (simulation
        parameters, environment settings, boundary conditions).

        This format supports compression for the voxel data. Enabling compression allows
        for larger models, but it may introduce geometry errors that particularly affect
        small models.

        The .vxa file type can be opened using VoxCad simulation software. However, it
        cannot currently be reopened by a VoxelFuse script.

        Args:
            filename: File name
            compression: Enable/disable voxel data compression
        
        Returns:
            None
        &#34;&#34;&#34;
        self.cleanTempControlGroups()
        f = open(filename + &#39;.vxa&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        writeHeader(f, &#39;1.0&#39;, &#39;ISO-8859-1&#39;)
        writeOpen(f, &#39;VXA Version=&#34;&#39; + str(1.1) + &#39;&#34;&#39;, 0)
        self.writeSimData(f)
        self.writeEnvironmentData(f)
        self.writeSensors(f)
        self.writeTempControls(f)
        self.writeDisconnections(f)
        self.__model.writeVXCData(f, compression)
        writeClos(f, &#39;VXA&#39;, 0)
        f.close()

    # Write simulator settings to file
    def writeSimData(self, f: TextIO):
        &#34;&#34;&#34;
        Write simulation parameters to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        # Simulator settings
        writeOpen(f, &#39;Simulator&#39;, 0)
        writeOpen(f, &#39;Integration&#39;, 1)
        writeData(f, &#39;Integrator&#39;, self.__integrator, 2)
        writeData(f, &#39;DtFrac&#39;, self.__dtFraction, 2)
        writeClos(f, &#39;Integration&#39;, 1)

        writeOpen(f, &#39;Damping&#39;, 1)
        writeData(f, &#39;BondDampingZ&#39;, self.__dampingBond, 2)
        writeData(f, &#39;ColDampingZ&#39;, self.__collisionDamping, 2)
        writeData(f, &#39;SlowDampingZ&#39;, self.__dampingEnvironment, 2)
        writeClos(f, &#39;Damping&#39;, 1)

        writeOpen(f, &#39;Collisions&#39;, 1)
        writeData(f, &#39;SelfColEnabled&#39;, int(self.__collisionEnable), 2)
        writeData(f, &#39;ColSystem&#39;, self.__collisionSystem, 2)
        writeData(f, &#39;CollisionHorizon&#39;, self.__collisionHorizon, 2)
        writeClos(f, &#39;Collisions&#39;, 1)

        writeOpen(f, &#39;Features&#39;, 1)
        writeData(f, &#39;BlendingEnabled&#39;, int(self.__blendingEnable), 2)
        writeData(f, &#39;XMixRadius&#39;, self.__xMixRadius, 2)
        writeData(f, &#39;YMixRadius&#39;, self.__yMixRadius, 2)
        writeData(f, &#39;ZMixRadius&#39;, self.__zMixRadius, 2)
        writeData(f, &#39;BlendModel&#39;, self.__blendingModel, 2)
        writeData(f, &#39;PolyExp&#39;, self.__polyExp, 2)
        writeData(f, &#39;VolumeEffectsEnabled&#39;, int(self.__volumeEffectsEnable), 2)
        writeClos(f, &#39;Features&#39;, 1)

        writeOpen(f, &#39;StopCondition&#39;, 1)
        writeData(f, &#39;StopConditionType&#39;, self.__stopConditionType.value, 2)
        writeData(f, &#39;StopConditionValue&#39;, self.__stopConditionValue, 2)
        writeClos(f, &#39;StopCondition&#39;, 1)

        writeOpen(f, &#39;EquilibriumMode&#39;, 1)
        writeData(f, &#39;EquilibriumModeEnabled&#39;, int(self.__equilibriumModeEnable), 2)
        writeClos(f, &#39;EquilibriumMode&#39;, 1)
        writeClos(f, &#39;Simulator&#39;, 0)

    # Write environment settings to file
    def writeEnvironmentData(self, f: TextIO):
        &#34;&#34;&#34;
        Write simulation environment parameters to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        # Environment settings
        writeOpen(f, &#39;Environment&#39;, 0)
        writeOpen(f, &#39;Boundary_Conditions&#39;, 1)
        writeData(f, &#39;NumBCs&#39;, len(self.__bcRegions), 2)
        for bc in self.__bcRegions:
            writeOpen(f, &#39;FRegion&#39;, 2)
            if bc.name is not None:
                writeData(f, &#39;Name&#39;, bc.name, 3)
            writeData(f, &#39;PrimType&#39;, int(bc.shape.value), 3)
            writeData(f, &#39;X&#39;, bc.position[0], 3)
            writeData(f, &#39;Y&#39;, bc.position[1], 3)
            writeData(f, &#39;Z&#39;, bc.position[2], 3)
            writeData(f, &#39;dX&#39;, bc.size[0], 3)
            writeData(f, &#39;dY&#39;, bc.size[1], 3)
            writeData(f, &#39;dZ&#39;, bc.size[2], 3)
            writeData(f, &#39;Radius&#39;, bc.radius, 3)
            writeData(f, &#39;R&#39;, bc.color[0], 3)
            writeData(f, &#39;G&#39;, bc.color[1], 3)
            writeData(f, &#39;B&#39;, bc.color[2], 3)
            writeData(f, &#39;alpha&#39;, bc.color[3], 3)
            writeData(f, &#39;DofFixed&#39;, bc.fixed_dof, 3)
            writeData(f, &#39;ForceX&#39;, bc.force[0], 3)
            writeData(f, &#39;ForceY&#39;, bc.force[1], 3)
            writeData(f, &#39;ForceZ&#39;, bc.force[2], 3)
            writeData(f, &#39;TorqueX&#39;, bc.torque[0], 3)
            writeData(f, &#39;TorqueY&#39;, bc.torque[1], 3)
            writeData(f, &#39;TorqueZ&#39;, bc.torque[2], 3)
            writeData(f, &#39;DisplaceX&#39;, bc.displacement[0] * 1e-3, 3)
            writeData(f, &#39;DisplaceY&#39;, bc.displacement[1] * 1e-3, 3)
            writeData(f, &#39;DisplaceZ&#39;, bc.displacement[2] * 1e-3, 3)
            writeData(f, &#39;AngDisplaceX&#39;, bc.angular_displacement[0], 3)
            writeData(f, &#39;AngDisplaceY&#39;, bc.angular_displacement[1], 3)
            writeData(f, &#39;AngDisplaceZ&#39;, bc.angular_displacement[2], 3)
            writeClos(f, &#39;FRegion&#39;, 2)
        writeClos(f, &#39;Boundary_Conditions&#39;, 1)

        writeOpen(f, &#39;Gravity&#39;, 1)
        writeData(f, &#39;GravEnabled&#39;, int(self.__gravityEnable), 2)
        writeData(f, &#39;GravAcc&#39;, self.__gravityValue, 2)
        writeData(f, &#39;FloorEnabled&#39;, int(self.__floorEnable), 2)
        writeClos(f, &#39;Gravity&#39;, 1)

        writeOpen(f, &#39;Thermal&#39;, 1)
        writeData(f, &#39;TempEnabled&#39;, int(self.__temperatureEnable), 2)
        writeData(f, &#39;TempAmplitude&#39;, self.__temperatureVaryAmplitude, 2)
        writeData(f, &#39;TempBase&#39;, self.__temperatureBaseValue, 2)
        writeData(f, &#39;VaryTempEnabled&#39;, int(self.__temperatureVaryEnable), 2)
        writeData(f, &#39;TempPeriod&#39;, self.__temperatureVaryPeriod, 2)
        writeData(f, &#39;TempOffset&#39;, self.__temperatureVaryOffset, 2)
        writeClos(f, &#39;Thermal&#39;, 1)

        writeData(f, &#39;GrowthAmplitude&#39;, self.__growthAmplitude, 1)
        writeClos(f, &#39;Environment&#39;, 0)

    def writeSensors(self, f: TextIO):
        &#34;&#34;&#34;
        Write voxel sensors to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        writeOpen(f, &#39;Sensors&#39;, 0)
        for sensor in self.__sensors:
            writeOpen(f, &#39;Sensor&#39;, 1)
            if sensor.name is not None:
                writeData(f, &#39;Name&#39;, sensor.name, 2)
            writeData(f, &#39;Location&#39;, str(sensor.coords).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
            writeData(f, &#39;Axis&#39;, sensor.axis.value, 2)
            writeClos(f, &#39;Sensor&#39;, 1)
        writeClos(f, &#39;Sensors&#39;, 0)

    def writeTempControls(self, f: TextIO):
        &#34;&#34;&#34;
        Write temperature control element to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        writeData(f, &#39;EnableHydrogelModel&#39;, int(self.__hydrogelModelEnable), 0)

        writeOpen(f, &#39;TempControls&#39;, 0)
        for group in self.__localTempControls:
            writeOpen(f, &#39;Element&#39;, 1)

            if group.name is not None:
                writeData(f, &#39;Name&#39;, group.name, 2)

            writeOpen(f, &#39;Locations&#39;, 2)
            for loc in group.locations:
                writeData(f, &#39;Location&#39;, str(loc).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 3)
            writeClos(f, &#39;Locations&#39;, 2)

            writeOpen(f, &#39;Keyframes&#39;, 2)
            for keyframe in group.keyframes:
                writeOpen(f, &#39;Keyframe&#39;, 3)
                writeData(f, &#39;TimeValue&#39;, keyframe.time_value, 4)
                writeData(f, &#39;AmplitudePos&#39;, keyframe.amplitude_pos, 4)
                writeData(f, &#39;AmplitudeNeg&#39;, keyframe.amplitude_neg, 4)
                writeData(f, &#39;PercentPos&#39;, keyframe.percent_pos, 4)
                writeData(f, &#39;Period&#39;, keyframe.period, 4)
                writeData(f, &#39;PhaseOffset&#39;, keyframe.phase_offset, 4)
                writeData(f, &#39;TempOffset&#39;, keyframe.temp_offset, 4)
                writeData(f, &#39;ConstantTemp&#39;, int(keyframe.const_temp), 4)
                writeData(f, &#39;SquareWave&#39;, int(keyframe.square_wave), 4)
                writeClos(f, &#39;Keyframe&#39;, 3)
            writeClos(f, &#39;Keyframes&#39;, 2)

            writeClos(f, &#39;Element&#39;, 1)
        writeClos(f, &#39;TempControls&#39;, 0)

    def writeDisconnections(self, f: TextIO):
        &#34;&#34;&#34;
        Write bond disconnections to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        writeOpen(f, &#39;Disconnections&#39;, 0)
        for dc in self.__disconnections:
            writeOpen(f, &#39;Break&#39;, 1)
            writeData(f, &#39;Voxel1&#39;, str(dc.vx1).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
            writeData(f, &#39;Voxel2&#39;, str(dc.vx2).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
            writeClos(f, &#39;Break&#39;, 1)
        writeClos(f, &#39;Disconnections&#39;, 0)

    def runSim(self, filename: str = &#39;temp&#39;, value_map: int = 0, delete_files: bool = True, log_interval: int = -1, history_interval: int = -1, voxelyze_on_path: bool = False, wsl: bool = False):
        &#34;&#34;&#34;
        Run a Simulation object using Voxelyze.

        This function will create a .vxa file, run the file with Voxelyze, and then load the .xml results file into
        the results attribute of the Simulation object. Enabling delete_files will delete both the .vxa and .xml files
        once the results have been loaded.

        History files can be viewed using https://github.com/voxcraft/voxcraft-viz

        Args:
            filename: File name for .vxa and .xml files
            value_map: Index of the desired value map type
            log_interval: Set the step interval at which sensor log entries should be recorded, -1 to disable log
            history_interval: Set the step interval at which history file entries should be recorded, -1 for default interval
            delete_files: Enable/disable deleting simulation file when process is complete
            voxelyze_on_path: Enable/disable using system Voxelyze rather than bundled Voxelyze
            wsl: Enable/disable using Windows Subsystem for Linux with bundled Voxelyze
        
        Returns:
            None
        &#34;&#34;&#34;
        # Generate results file/directory names
        filename = filename + &#39;_&#39; + str(self.id)
        dirname = &#39;sim_results_&#39; + str(self.date)

        # Create results directory
        if not os.path.exists(dirname):
            os.makedirs(dirname)

        # Create simulation file
        self.saveVXA(dirname + &#39;/&#39; + filename)

        if voxelyze_on_path:
            command_string = &#39;voxelyze&#39;
        else:
            # Check OS type
            if os.name.startswith(&#39;nt&#39;): # Windows
                if wsl:
                    command_string = &#39;wsl &#34;&#39; + os.path.dirname(os.path.realpath(__file__)).replace(&#39;C:&#39;, &#39;/mnt/c&#39;).replace(&#39;\\&#39;, &#39;/&#39;) + &#39;/utils/voxelyze&#34;&#39;
                else:
                    command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}\\utils\\voxelyze.exe&#34;&#39;
            else: # Linux
                command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}/utils/voxelyze&#34;&#39;

        command_string = command_string + &#39; -f &#39; + dirname + &#39;/&#39; + filename + &#39;.vxa -o &#39; + dirname + &#39;/&#39; + filename + &#39; -vm &#39; + str(value_map) + &#39; -p&#39;

        if log_interval &gt; 0:
            command_string = command_string + &#39; -log-interval &#39; + str(log_interval)

        if history_interval &gt; 0:
            command_string = command_string + &#39; -history-interval &#39; + str(history_interval)

        print(&#39;Launching Voxelyze using: &#39; + command_string)
        p = subprocess.Popen(command_string, shell=True)
        p.wait()

        # Open simulation results
        f = open(dirname + &#39;/&#39; + filename + &#39;.xml&#39;, &#39;r&#39;)
        #print(&#39;Opening file: &#39; + f.name)
        data = f.readlines()
        f.close()

        # Clear any previous results
        self.results = []

        # Find start and end locations for individual sensors
        startLoc = []
        endLoc = []
        for row in range(len(data)): # tqdm(range(len(data)), desc=&#39;Finding sensor tags&#39;):
            data[row] = data[row].replace(&#39;\t&#39;, &#39;&#39;)
            if data[row][:-1] == &#39;&lt;Sensor&gt;&#39;:
                startLoc.append(row)
            elif data[row][:-1] == &#39;&lt;/Sensor&gt;&#39;:
                endLoc.append(row)

        # Read the data from each sensor
        sensor_count = len(startLoc)
        if sensor_count &gt; 0:
            for sensor in range(sensor_count): # tqdm(range(len(startLoc)), desc=&#39;Reading sensor results&#39;):
                # Create a dictionary to hold the current sensor results
                sensorResults = {}

                # Read the data from each sensor tag
                for row in range(startLoc[sensor]+1, endLoc[sensor]):
                    # Determine the current tag
                    tag = &#39;&#39;
                    for col in range(1, len(data[row])):
                        if data[row][col] == &#39;&gt;&#39;:
                            tag = data[row][1:col]
                            break

                    # Remove the tags and newline to determine the current value
                    data[row] = data[row].replace(&#39;&lt;&#39;+tag+&#39;&gt;&#39;, &#39;&#39;).replace(&#39;&lt;/&#39;+tag+&#39;&gt;&#39;, &#39;&#39;)
                    value = data[row][:-1]

                    # Combine the current tag and value
                    if tag == &#39;Location&#39;:
                        coords =  tuple(map(int, value.split(&#39; &#39;)))
                        x = coords[0] + self.__model.coords[0]
                        y = coords[1] + self.__model.coords[1]
                        z = coords[2] + self.__model.coords[2]
                        currentResult = {tag:(x, y, z)}
                    elif &#39; &#39; in value:
                        currentResult = {tag:tuple(map(float, value.split(&#39; &#39;)))}
                    else:
                        currentResult = {tag:float(value)}

                    # Add the current tag and value to the sensor results dictionary
                    sensorResults.update(currentResult)

                # Append the results dictionary for the current sensor to the simulation results list
                self.results.append(sensorResults)
        else:
            print(&#39;No sensors found&#39;)

        if os.path.exists(&#39;value_map.txt&#39;):
            # Open simulation value map results
            f = open(&#39;value_map.txt&#39;, &#39;r&#39;)
            print(&#39;Opening file: &#39; + f.name)
            data = f.readlines()
            f.close()

            # Clear any previous results
            self.valueMap = np.zeros_like(self.__model.voxels, dtype=np.float32)

            # Get map size
            x_len = self.valueMap.shape[0]
            y_len = self.valueMap.shape[1]
            z_len = self.valueMap.shape[2]

            for z in range(z_len): # tqdm(range(z_len), desc=&#39;Loading layers&#39;):
                vals = np.array(data[z][:-2].split(&#34;,&#34;), dtype=np.float32)
                for y in range(y_len):
                    self.valueMap[:, y, z] = vals[y*x_len:(y+1)*x_len]

        # Remove temporary files
        if delete_files:
            os.remove(dirname + &#39;/&#39; + filename + &#39;.vxa&#39;)
            os.remove(dirname + &#39;/&#39; + filename + &#39;.xml&#39;)

            if os.path.exists(dirname + &#39;/value_map.txt&#39;):
                os.remove(dirname + &#39;/value_map.txt&#39;)

    def runSimVoxCad(self, filename: str = &#39;temp&#39;, delete_files: bool = True, voxcad_on_path: bool = False, wsl: bool = False):
        &#34;&#34;&#34;
        Run a Simulation object using the VoxCad GUI.

        ----

        Example:

        ``simulation = Simulation(modelResult)``

        ``simulation.setCollision()``

        ``simulation.setStopCondition(StopCondition.TIME_VALUE, 0.01)``

        ``simulation.runSimVoxCad(&#39;collision_sim_1&#39;, delete_files=False)``

        ----

        Args:
            filename: File name
            delete_files: Enable/disable deleting simulation file when VoxCad is closed
            voxcad_on_path: Enable/disable using system VoxCad rather than bundled VoxCad
            wsl: Enable/disable using Windows Subsystem for Linux with bundled VoxCad
        
        Returns:
            None
        &#34;&#34;&#34;
        # Generate file name
        filename = filename + &#39;_&#39; + str(self.id)

        # Create simulation file
        self.saveVXA(filename)

        if voxcad_on_path:
            command_string = &#39;voxcad &#39;
        else:
            # Check OS type
            if os.name.startswith(&#39;nt&#39;): # Windows
                if wsl:
                    command_string = &#39;wsl &#34;&#39; + os.path.dirname(os.path.realpath(__file__)).replace(&#39;C:&#39;, &#39;/mnt/c&#39;).replace(&#39;\\&#39;, &#39;/&#39;) + &#39;/utils/VoxCad&#34; &#39;
                else:
                    command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}\\utils\\VoxCad.exe&#34; &#39;
            else: # Linux
                command_string =  f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}/utils/VoxCad&#34; &#39;

        command_string = command_string + filename + &#39;.vxa&#39;

        print(&#39;Launching VoxCad using: &#39; + command_string)
        p = subprocess.Popen(command_string, shell=True)
        p.wait()

        if delete_files:
            print(&#39;Removing file: &#39; + filename + &#39;.vxa&#39;)
            os.remove(filename + &#39;.vxa&#39;)

    def saveResults(self, filename):
        &#34;&#34;&#34;
        Saves a simulation&#39;s results dictionary to a .csv file.

        Args:
            filename: Name of output file

        Returns:
            None
        &#34;&#34;&#34;
        # Get result table keys and size
        keys = list(self.results[0].keys())
        rows = len(self.results)
        cols = len(keys)

        # Create results file
        f = open(filename + &#39;.csv&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        # Write headings
        f.write(&#39;Sensor&#39;)
        for c in range(cols):
            f.write(&#39;,&#39; + str(keys[c]))
        f.write(&#39;\n&#39;)

        # Write values
        for r in range(rows):
            f.write(str(r))
            vals = list(self.results[r].values())
            for c in range(cols):
                f.write(&#39;,&#39; + str(vals[c]).replace(&#39;,&#39;, &#39; &#39;))
            f.write(&#39;\n&#39;)

        # Close file
        f.close()

class MultiSimulation:
    &#34;&#34;&#34;
    MultiSimulation object that holds settings for generating a simulation and running multiple parallel trials of it using different parameters.
    &#34;&#34;&#34;

    def __init__(self, setup_fcn, setup_params: List[Tuple], thread_count: int = -1):
        &#34;&#34;&#34;
        Initialize a MultiSimulation object.

        Args:
            setup_fcn: Function to use for initializing Simulation objects. Should take a single tuple as an input and return a single Simulation object.
            setup_params: List containing the desired input tuples for setup_fcn
            thread_count: Maximum number of CPU threads, -1 to auto-detect
        &#34;&#34;&#34;
        self.__setup_fcn = setup_fcn
        self.__setup_params = setup_params

        if thread_count &gt; 0:
            self.__thread_count = thread_count
        else:
            max_threads = os.cpu_count()
            self.__thread_count = max(1, max_threads - 2)  # Default to leaving 1 core (2 threads) free, minimum of 1 thread

            # Initialize result arrays
        self.total_time = 0
        self.displacement_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))
        self.time_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))

    def getParams(self):
        &#34;&#34;&#34;
        Get the current simulation setup parameters.
        
        Returns:
            List containing the current input tuples for setup_fcn
        &#34;&#34;&#34;
        return self.__setup_params

    def setParams(self, setup_params: List[Tuple]):
        &#34;&#34;&#34;
        Update the simulation setup parameters.

        Args:
            setup_params: List containing the desired input tuples for setup_fcn
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__setup_params = setup_params
        self.displacement_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))
        self.time_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))

    def confirmSimCount(self):
        &#34;&#34;&#34;
        Print the number of simulations to be run and confirm that the user would like to continue.
        
        Returns:
            None
        &#34;&#34;&#34;
        # Check if results directory already exists
        dirname = &#39;sim_results_&#39; + str(date.today())
        if os.path.exists(dirname):
            print(&#34;WARNING: Previous results exist and may be overwritten: &#34; + str(dirname))

        print(&#34;Trials to run: &#34; + str(len(self.__setup_params)))
        print(&#34;Max CPU threads: &#34; + str(self.__thread_count))
        input(&#34;Press Enter to continue...&#34;)

    def run(self, enable_log : bool = False, fine_log: bool = False):
        &#34;&#34;&#34;
        Run all simulation configurations and save the results.

        History files can be viewed using https://github.com/voxcraft/voxcraft-viz

        Args:
            enable_log: Enable saving sensor log files
            fine_log: If enabled, save entries in sensor logs and history files 100x as frequently
        
        Returns:
            None
        &#34;&#34;&#34;
        # Save start time
        time_started = time.time()

        # Set up simulations
        sim_id = 0
        sim_array = []
        for config in tqdm(self.__setup_params, desc=&#39;Initializing simulations&#39;):
            sim = self.__setup_fcn(config)

            # Use automatic sim id if one is not already set
            if sim.id == 0:
                sim.id = sim_id
                sim_id = sim_id + 1

            sim_array.append(sim)

        # Initialize processing pool
        p = multiprocessing.Pool(self.__thread_count, initializer=poolInit, initargs=(self.displacement_result, self.time_result))
        if enable_log:
            if fine_log:
                p.map(simProcessLogFine, sim_array)
            else:
                p.map(simProcessLog, sim_array)
        else:
            p.map(simProcess, sim_array)

        # Get elapsed time
        time_finished = time.time()
        self.total_time = time_finished - time_started

    def export(self, filename: str, labels: List[str], parameters_only: bool = False):
        &#34;&#34;&#34;
        Export a CSV file containing simulation setup parameters and the corresponding simulation results.

        Args:
            filename: File name
            labels: Column headers for simulation setup parameters
            parameters_only: Only export setup parameters and not simulation results
        
        Returns:
            None
        &#34;&#34;&#34;
        # Add labels for results
        if not parameters_only:
            labels.append(&#39;Displacement (m)&#39;)
            labels.append(&#39;Simulation Time (s)&#39;)

        # Get result table size
        rows = len(self.__setup_params)
        cols = len(labels)

        # Create results file
        f = open(filename + &#39;.csv&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        # Write sim info
        if not parameters_only:
            f.write(&#39;Simulation Elapsed Time (mins),&#39; + str(self.total_time / 60.0) + &#39;\n&#39;)

        f.write(&#39;Trial Count,&#39; + str(rows) + &#39;\n&#39;)
        f.write(&#39;Max Thread Count,&#39; + str(self.__thread_count) + &#39;\n&#39;)
        f.write(&#39;\n&#39;)

        # Write headings
        for c in range(cols):
            f.write(labels[c] + &#39;,&#39;)
        f.write(&#39;\n&#39;)

        # Write values
        for r in range(rows):
            for c in range(cols - 2):
                f.write(str(self.__setup_params[r][c]) + &#39;,&#39;)

            if not parameters_only:
                f.write(str(self.displacement_result[r]) + &#39;,&#39;)
                f.write(str(self.time_result[r]) + &#39;,&#39;)

            f.write(&#39;\n&#39;)

        # Close file
        f.close()

    def exportVXA(self, filename: str, config_number: int = -1):
        &#34;&#34;&#34;
        Export VXA files for all or specified simulation configurations.

        Args:
            filename: File name
            config_number: Config to export, -1 to export all configs
        
        Returns:
            None
        &#34;&#34;&#34;
        if config_number == -1:
            for config in tqdm(self.__setup_params, desc=&#39;Saving simulations&#39;):
                sim = self.__setup_fcn(config)
                sim.saveVXA(filename + &#39;_&#39; + str(config[0]))
        else:
            config = self.__setup_params[config_number]
            sim = self.__setup_fcn(config)
            sim.saveVXA(filename)

# Helper functions
def poolInit(disp_result_array, t_result_array):
    &#34;&#34;&#34;
    Initialize shared result variables.

    Args:
        disp_result_array: Multiprocessing array to hold displacement results
        t_result_array: Multiprocessing array to hold time results

    Returns:
        None
    &#34;&#34;&#34;
    global disp_result, t_result
    disp_result = disp_result_array
    t_result = t_result_array

def simProcess(simulation: Simulation):
    &#34;&#34;&#34;
    Simulation process.

    Args:
        simulation: Simulation object to run

    Returns:
        None
    &#34;&#34;&#34;
    print(&#39;Process &#39; + str(simulation.id) + &#39; starting&#39;)

    # Run simulation
    time_process_started = time.time()
    simulation.runSim(&#39;multisim&#39;, log_interval=-1, history_interval=100000, wsl=True)
    time_process_finished = time.time()

    # Read results
    try:
        disp_x = float(simulation.results[0][&#39;Position&#39;][0]) - float(simulation.results[0][&#39;InitialPosition&#39;][0])
        disp_y = float(simulation.results[0][&#39;Position&#39;][1]) - float(simulation.results[0][&#39;InitialPosition&#39;][1])
        disp_z = float(simulation.results[0][&#39;Position&#39;][2]) - float(simulation.results[0][&#39;InitialPosition&#39;][2])
        disp_result[simulation.id] = np.sqrt((disp_x**2) + (disp_y**2) + (disp_z**2))
        t_result[simulation.id] = time_process_finished - time_process_started
    except IndexError:
        print(&#39;Unable to load sensor results&#39;)

    # Finished
    print(&#39;Process &#39; + str(simulation.id) + &#39; finished&#39;)

def simProcessLog(simulation: Simulation):
    &#34;&#34;&#34;
    Simulation process.

    Args:
        simulation: Simulation object to run

    Returns:
        None
    &#34;&#34;&#34;
    print(&#39;Process &#39; + str(simulation.id) + &#39; starting&#39;)

    # Run simulation
    time_process_started = time.time()
    simulation.runSim(&#39;multisim&#39;, log_interval=100000, history_interval=100000, wsl=True)
    time_process_finished = time.time()

    # Read results
    try:
        disp_x = float(simulation.results[0][&#39;Position&#39;][0]) - float(simulation.results[0][&#39;InitialPosition&#39;][0])
        disp_y = float(simulation.results[0][&#39;Position&#39;][1]) - float(simulation.results[0][&#39;InitialPosition&#39;][1])
        disp_z = float(simulation.results[0][&#39;Position&#39;][2]) - float(simulation.results[0][&#39;InitialPosition&#39;][2])
        disp_result[simulation.id] = np.sqrt((disp_x**2) + (disp_y**2) + (disp_z**2))
        t_result[simulation.id] = time_process_finished - time_process_started
    except IndexError:
        print(&#39;Unable to load sensor results&#39;)

    # Finished
    print(&#39;Process &#39; + str(simulation.id) + &#39; finished&#39;)

def simProcessLogFine(simulation: Simulation):
    &#34;&#34;&#34;
    Simulation process.

    Args:
        simulation: Simulation object to run

    Returns:
        None
    &#34;&#34;&#34;
    print(&#39;Process &#39; + str(simulation.id) + &#39; starting&#39;)

    # Run simulation
    time_process_started = time.time()
    simulation.runSim(&#39;multisim&#39;, log_interval=1000, history_interval=1000, wsl=True)
    time_process_finished = time.time()

    # Read results
    try:
        disp_x = float(simulation.results[0][&#39;Position&#39;][0]) - float(simulation.results[0][&#39;InitialPosition&#39;][0])
        disp_y = float(simulation.results[0][&#39;Position&#39;][1]) - float(simulation.results[0][&#39;InitialPosition&#39;][1])
        disp_z = float(simulation.results[0][&#39;Position&#39;][2]) - float(simulation.results[0][&#39;InitialPosition&#39;][2])
        disp_result[simulation.id] = np.sqrt((disp_x**2) + (disp_y**2) + (disp_z**2))
        t_result[simulation.id] = time_process_finished - time_process_started
    except IndexError:
        print(&#39;Unable to load sensor results&#39;)

    # Finished
    print(&#39;Process &#39; + str(simulation.id) + &#39; finished&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="voxelfuse.simulation.poolInit"><code class="name flex">
<span>def <span class="ident">poolInit</span></span>(<span>disp_result_array, t_result_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize shared result variables.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>disp_result_array</code></strong></dt>
<dd>Multiprocessing array to hold displacement results</dd>
<dt><strong><code>t_result_array</code></strong></dt>
<dd>Multiprocessing array to hold time results</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poolInit(disp_result_array, t_result_array):
    &#34;&#34;&#34;
    Initialize shared result variables.

    Args:
        disp_result_array: Multiprocessing array to hold displacement results
        t_result_array: Multiprocessing array to hold time results

    Returns:
        None
    &#34;&#34;&#34;
    global disp_result, t_result
    disp_result = disp_result_array
    t_result = t_result_array</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.simProcess"><code class="name flex">
<span>def <span class="ident">simProcess</span></span>(<span>simulation:Â <a title="voxelfuse.simulation.Simulation" href="#voxelfuse.simulation.Simulation">Simulation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulation process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>simulation</code></strong></dt>
<dd>Simulation object to run</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simProcess(simulation: Simulation):
    &#34;&#34;&#34;
    Simulation process.

    Args:
        simulation: Simulation object to run

    Returns:
        None
    &#34;&#34;&#34;
    print(&#39;Process &#39; + str(simulation.id) + &#39; starting&#39;)

    # Run simulation
    time_process_started = time.time()
    simulation.runSim(&#39;multisim&#39;, log_interval=-1, history_interval=100000, wsl=True)
    time_process_finished = time.time()

    # Read results
    try:
        disp_x = float(simulation.results[0][&#39;Position&#39;][0]) - float(simulation.results[0][&#39;InitialPosition&#39;][0])
        disp_y = float(simulation.results[0][&#39;Position&#39;][1]) - float(simulation.results[0][&#39;InitialPosition&#39;][1])
        disp_z = float(simulation.results[0][&#39;Position&#39;][2]) - float(simulation.results[0][&#39;InitialPosition&#39;][2])
        disp_result[simulation.id] = np.sqrt((disp_x**2) + (disp_y**2) + (disp_z**2))
        t_result[simulation.id] = time_process_finished - time_process_started
    except IndexError:
        print(&#39;Unable to load sensor results&#39;)

    # Finished
    print(&#39;Process &#39; + str(simulation.id) + &#39; finished&#39;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.simProcessLog"><code class="name flex">
<span>def <span class="ident">simProcessLog</span></span>(<span>simulation:Â <a title="voxelfuse.simulation.Simulation" href="#voxelfuse.simulation.Simulation">Simulation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulation process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>simulation</code></strong></dt>
<dd>Simulation object to run</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simProcessLog(simulation: Simulation):
    &#34;&#34;&#34;
    Simulation process.

    Args:
        simulation: Simulation object to run

    Returns:
        None
    &#34;&#34;&#34;
    print(&#39;Process &#39; + str(simulation.id) + &#39; starting&#39;)

    # Run simulation
    time_process_started = time.time()
    simulation.runSim(&#39;multisim&#39;, log_interval=100000, history_interval=100000, wsl=True)
    time_process_finished = time.time()

    # Read results
    try:
        disp_x = float(simulation.results[0][&#39;Position&#39;][0]) - float(simulation.results[0][&#39;InitialPosition&#39;][0])
        disp_y = float(simulation.results[0][&#39;Position&#39;][1]) - float(simulation.results[0][&#39;InitialPosition&#39;][1])
        disp_z = float(simulation.results[0][&#39;Position&#39;][2]) - float(simulation.results[0][&#39;InitialPosition&#39;][2])
        disp_result[simulation.id] = np.sqrt((disp_x**2) + (disp_y**2) + (disp_z**2))
        t_result[simulation.id] = time_process_finished - time_process_started
    except IndexError:
        print(&#39;Unable to load sensor results&#39;)

    # Finished
    print(&#39;Process &#39; + str(simulation.id) + &#39; finished&#39;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.simProcessLogFine"><code class="name flex">
<span>def <span class="ident">simProcessLogFine</span></span>(<span>simulation:Â <a title="voxelfuse.simulation.Simulation" href="#voxelfuse.simulation.Simulation">Simulation</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulation process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>simulation</code></strong></dt>
<dd>Simulation object to run</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simProcessLogFine(simulation: Simulation):
    &#34;&#34;&#34;
    Simulation process.

    Args:
        simulation: Simulation object to run

    Returns:
        None
    &#34;&#34;&#34;
    print(&#39;Process &#39; + str(simulation.id) + &#39; starting&#39;)

    # Run simulation
    time_process_started = time.time()
    simulation.runSim(&#39;multisim&#39;, log_interval=1000, history_interval=1000, wsl=True)
    time_process_finished = time.time()

    # Read results
    try:
        disp_x = float(simulation.results[0][&#39;Position&#39;][0]) - float(simulation.results[0][&#39;InitialPosition&#39;][0])
        disp_y = float(simulation.results[0][&#39;Position&#39;][1]) - float(simulation.results[0][&#39;InitialPosition&#39;][1])
        disp_z = float(simulation.results[0][&#39;Position&#39;][2]) - float(simulation.results[0][&#39;InitialPosition&#39;][2])
        disp_result[simulation.id] = np.sqrt((disp_x**2) + (disp_y**2) + (disp_z**2))
        t_result[simulation.id] = time_process_finished - time_process_started
    except IndexError:
        print(&#39;Unable to load sensor results&#39;)

    # Finished
    print(&#39;Process &#39; + str(simulation.id) + &#39; finished&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="voxelfuse.simulation.Axis"><code class="flex name class">
<span>class <span class="ident">Axis</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for axes and planes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Axis(Enum):
    &#34;&#34;&#34;
    Options for axes and planes.
    &#34;&#34;&#34;
    NONE = -1
    X = 0
    Y = 1
    Z = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.simulation.Axis.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.Axis.X"><code class="name">var <span class="ident">X</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.Axis.Y"><code class="name">var <span class="ident">Y</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.Axis.Z"><code class="name">var <span class="ident">Z</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.simulation.BCShape"><code class="flex name class">
<span>class <span class="ident">BCShape</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for simulation boundary condition shapes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BCShape(Enum):
    &#34;&#34;&#34;
    Options for simulation boundary condition shapes.
    &#34;&#34;&#34;
    BOX = 0
    CYLINDER = 1
    SPHERE = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.simulation.BCShape.BOX"><code class="name">var <span class="ident">BOX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.BCShape.CYLINDER"><code class="name">var <span class="ident">CYLINDER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.BCShape.SPHERE"><code class="name">var <span class="ident">SPHERE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="voxelfuse.simulation.MultiSimulation"><code class="flex name class">
<span>class <span class="ident">MultiSimulation</span></span>
<span>(</span><span>setup_fcn, setup_params:Â List[Tuple[]], thread_count:Â intÂ =Â -1)</span>
</code></dt>
<dd>
<div class="desc"><p>MultiSimulation object that holds settings for generating a simulation and running multiple parallel trials of it using different parameters.</p>
<p>Initialize a MultiSimulation object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>setup_fcn</code></strong></dt>
<dd>Function to use for initializing Simulation objects. Should take a single tuple as an input and return a single Simulation object.</dd>
<dt><strong><code>setup_params</code></strong></dt>
<dd>List containing the desired input tuples for setup_fcn</dd>
<dt><strong><code>thread_count</code></strong></dt>
<dd>Maximum number of CPU threads, -1 to auto-detect</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiSimulation:
    &#34;&#34;&#34;
    MultiSimulation object that holds settings for generating a simulation and running multiple parallel trials of it using different parameters.
    &#34;&#34;&#34;

    def __init__(self, setup_fcn, setup_params: List[Tuple], thread_count: int = -1):
        &#34;&#34;&#34;
        Initialize a MultiSimulation object.

        Args:
            setup_fcn: Function to use for initializing Simulation objects. Should take a single tuple as an input and return a single Simulation object.
            setup_params: List containing the desired input tuples for setup_fcn
            thread_count: Maximum number of CPU threads, -1 to auto-detect
        &#34;&#34;&#34;
        self.__setup_fcn = setup_fcn
        self.__setup_params = setup_params

        if thread_count &gt; 0:
            self.__thread_count = thread_count
        else:
            max_threads = os.cpu_count()
            self.__thread_count = max(1, max_threads - 2)  # Default to leaving 1 core (2 threads) free, minimum of 1 thread

            # Initialize result arrays
        self.total_time = 0
        self.displacement_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))
        self.time_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))

    def getParams(self):
        &#34;&#34;&#34;
        Get the current simulation setup parameters.
        
        Returns:
            List containing the current input tuples for setup_fcn
        &#34;&#34;&#34;
        return self.__setup_params

    def setParams(self, setup_params: List[Tuple]):
        &#34;&#34;&#34;
        Update the simulation setup parameters.

        Args:
            setup_params: List containing the desired input tuples for setup_fcn
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__setup_params = setup_params
        self.displacement_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))
        self.time_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))

    def confirmSimCount(self):
        &#34;&#34;&#34;
        Print the number of simulations to be run and confirm that the user would like to continue.
        
        Returns:
            None
        &#34;&#34;&#34;
        # Check if results directory already exists
        dirname = &#39;sim_results_&#39; + str(date.today())
        if os.path.exists(dirname):
            print(&#34;WARNING: Previous results exist and may be overwritten: &#34; + str(dirname))

        print(&#34;Trials to run: &#34; + str(len(self.__setup_params)))
        print(&#34;Max CPU threads: &#34; + str(self.__thread_count))
        input(&#34;Press Enter to continue...&#34;)

    def run(self, enable_log : bool = False, fine_log: bool = False):
        &#34;&#34;&#34;
        Run all simulation configurations and save the results.

        History files can be viewed using https://github.com/voxcraft/voxcraft-viz

        Args:
            enable_log: Enable saving sensor log files
            fine_log: If enabled, save entries in sensor logs and history files 100x as frequently
        
        Returns:
            None
        &#34;&#34;&#34;
        # Save start time
        time_started = time.time()

        # Set up simulations
        sim_id = 0
        sim_array = []
        for config in tqdm(self.__setup_params, desc=&#39;Initializing simulations&#39;):
            sim = self.__setup_fcn(config)

            # Use automatic sim id if one is not already set
            if sim.id == 0:
                sim.id = sim_id
                sim_id = sim_id + 1

            sim_array.append(sim)

        # Initialize processing pool
        p = multiprocessing.Pool(self.__thread_count, initializer=poolInit, initargs=(self.displacement_result, self.time_result))
        if enable_log:
            if fine_log:
                p.map(simProcessLogFine, sim_array)
            else:
                p.map(simProcessLog, sim_array)
        else:
            p.map(simProcess, sim_array)

        # Get elapsed time
        time_finished = time.time()
        self.total_time = time_finished - time_started

    def export(self, filename: str, labels: List[str], parameters_only: bool = False):
        &#34;&#34;&#34;
        Export a CSV file containing simulation setup parameters and the corresponding simulation results.

        Args:
            filename: File name
            labels: Column headers for simulation setup parameters
            parameters_only: Only export setup parameters and not simulation results
        
        Returns:
            None
        &#34;&#34;&#34;
        # Add labels for results
        if not parameters_only:
            labels.append(&#39;Displacement (m)&#39;)
            labels.append(&#39;Simulation Time (s)&#39;)

        # Get result table size
        rows = len(self.__setup_params)
        cols = len(labels)

        # Create results file
        f = open(filename + &#39;.csv&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        # Write sim info
        if not parameters_only:
            f.write(&#39;Simulation Elapsed Time (mins),&#39; + str(self.total_time / 60.0) + &#39;\n&#39;)

        f.write(&#39;Trial Count,&#39; + str(rows) + &#39;\n&#39;)
        f.write(&#39;Max Thread Count,&#39; + str(self.__thread_count) + &#39;\n&#39;)
        f.write(&#39;\n&#39;)

        # Write headings
        for c in range(cols):
            f.write(labels[c] + &#39;,&#39;)
        f.write(&#39;\n&#39;)

        # Write values
        for r in range(rows):
            for c in range(cols - 2):
                f.write(str(self.__setup_params[r][c]) + &#39;,&#39;)

            if not parameters_only:
                f.write(str(self.displacement_result[r]) + &#39;,&#39;)
                f.write(str(self.time_result[r]) + &#39;,&#39;)

            f.write(&#39;\n&#39;)

        # Close file
        f.close()

    def exportVXA(self, filename: str, config_number: int = -1):
        &#34;&#34;&#34;
        Export VXA files for all or specified simulation configurations.

        Args:
            filename: File name
            config_number: Config to export, -1 to export all configs
        
        Returns:
            None
        &#34;&#34;&#34;
        if config_number == -1:
            for config in tqdm(self.__setup_params, desc=&#39;Saving simulations&#39;):
                sim = self.__setup_fcn(config)
                sim.saveVXA(filename + &#39;_&#39; + str(config[0]))
        else:
            config = self.__setup_params[config_number]
            sim = self.__setup_fcn(config)
            sim.saveVXA(filename)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="voxelfuse.simulation.MultiSimulation.confirmSimCount"><code class="name flex">
<span>def <span class="ident">confirmSimCount</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the number of simulations to be run and confirm that the user would like to continue.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def confirmSimCount(self):
    &#34;&#34;&#34;
    Print the number of simulations to be run and confirm that the user would like to continue.
    
    Returns:
        None
    &#34;&#34;&#34;
    # Check if results directory already exists
    dirname = &#39;sim_results_&#39; + str(date.today())
    if os.path.exists(dirname):
        print(&#34;WARNING: Previous results exist and may be overwritten: &#34; + str(dirname))

    print(&#34;Trials to run: &#34; + str(len(self.__setup_params)))
    print(&#34;Max CPU threads: &#34; + str(self.__thread_count))
    input(&#34;Press Enter to continue...&#34;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.MultiSimulation.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, filename:Â str, labels:Â List[str], parameters_only:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Export a CSV file containing simulation setup parameters and the corresponding simulation results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
<dt><strong><code>labels</code></strong></dt>
<dd>Column headers for simulation setup parameters</dd>
<dt><strong><code>parameters_only</code></strong></dt>
<dd>Only export setup parameters and not simulation results</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, filename: str, labels: List[str], parameters_only: bool = False):
    &#34;&#34;&#34;
    Export a CSV file containing simulation setup parameters and the corresponding simulation results.

    Args:
        filename: File name
        labels: Column headers for simulation setup parameters
        parameters_only: Only export setup parameters and not simulation results
    
    Returns:
        None
    &#34;&#34;&#34;
    # Add labels for results
    if not parameters_only:
        labels.append(&#39;Displacement (m)&#39;)
        labels.append(&#39;Simulation Time (s)&#39;)

    # Get result table size
    rows = len(self.__setup_params)
    cols = len(labels)

    # Create results file
    f = open(filename + &#39;.csv&#39;, &#39;w+&#39;)
    print(&#39;Saving file: &#39; + f.name)

    # Write sim info
    if not parameters_only:
        f.write(&#39;Simulation Elapsed Time (mins),&#39; + str(self.total_time / 60.0) + &#39;\n&#39;)

    f.write(&#39;Trial Count,&#39; + str(rows) + &#39;\n&#39;)
    f.write(&#39;Max Thread Count,&#39; + str(self.__thread_count) + &#39;\n&#39;)
    f.write(&#39;\n&#39;)

    # Write headings
    for c in range(cols):
        f.write(labels[c] + &#39;,&#39;)
    f.write(&#39;\n&#39;)

    # Write values
    for r in range(rows):
        for c in range(cols - 2):
            f.write(str(self.__setup_params[r][c]) + &#39;,&#39;)

        if not parameters_only:
            f.write(str(self.displacement_result[r]) + &#39;,&#39;)
            f.write(str(self.time_result[r]) + &#39;,&#39;)

        f.write(&#39;\n&#39;)

    # Close file
    f.close()</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.MultiSimulation.exportVXA"><code class="name flex">
<span>def <span class="ident">exportVXA</span></span>(<span>self, filename:Â str, config_number:Â intÂ =Â -1)</span>
</code></dt>
<dd>
<div class="desc"><p>Export VXA files for all or specified simulation configurations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
<dt><strong><code>config_number</code></strong></dt>
<dd>Config to export, -1 to export all configs</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportVXA(self, filename: str, config_number: int = -1):
    &#34;&#34;&#34;
    Export VXA files for all or specified simulation configurations.

    Args:
        filename: File name
        config_number: Config to export, -1 to export all configs
    
    Returns:
        None
    &#34;&#34;&#34;
    if config_number == -1:
        for config in tqdm(self.__setup_params, desc=&#39;Saving simulations&#39;):
            sim = self.__setup_fcn(config)
            sim.saveVXA(filename + &#39;_&#39; + str(config[0]))
    else:
        config = self.__setup_params[config_number]
        sim = self.__setup_fcn(config)
        sim.saveVXA(filename)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.MultiSimulation.getParams"><code class="name flex">
<span>def <span class="ident">getParams</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current simulation setup parameters.</p>
<h2 id="returns">Returns</h2>
<p>List containing the current input tuples for setup_fcn</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getParams(self):
    &#34;&#34;&#34;
    Get the current simulation setup parameters.
    
    Returns:
        List containing the current input tuples for setup_fcn
    &#34;&#34;&#34;
    return self.__setup_params</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.MultiSimulation.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, enable_log:Â boolÂ =Â False, fine_log:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run all simulation configurations and save the results.</p>
<p>History files can be viewed using <a href="https://github.com/voxcraft/voxcraft-viz">https://github.com/voxcraft/voxcraft-viz</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable_log</code></strong></dt>
<dd>Enable saving sensor log files</dd>
<dt><strong><code>fine_log</code></strong></dt>
<dd>If enabled, save entries in sensor logs and history files 100x as frequently</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, enable_log : bool = False, fine_log: bool = False):
    &#34;&#34;&#34;
    Run all simulation configurations and save the results.

    History files can be viewed using https://github.com/voxcraft/voxcraft-viz

    Args:
        enable_log: Enable saving sensor log files
        fine_log: If enabled, save entries in sensor logs and history files 100x as frequently
    
    Returns:
        None
    &#34;&#34;&#34;
    # Save start time
    time_started = time.time()

    # Set up simulations
    sim_id = 0
    sim_array = []
    for config in tqdm(self.__setup_params, desc=&#39;Initializing simulations&#39;):
        sim = self.__setup_fcn(config)

        # Use automatic sim id if one is not already set
        if sim.id == 0:
            sim.id = sim_id
            sim_id = sim_id + 1

        sim_array.append(sim)

    # Initialize processing pool
    p = multiprocessing.Pool(self.__thread_count, initializer=poolInit, initargs=(self.displacement_result, self.time_result))
    if enable_log:
        if fine_log:
            p.map(simProcessLogFine, sim_array)
        else:
            p.map(simProcessLog, sim_array)
    else:
        p.map(simProcess, sim_array)

    # Get elapsed time
    time_finished = time.time()
    self.total_time = time_finished - time_started</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.MultiSimulation.setParams"><code class="name flex">
<span>def <span class="ident">setParams</span></span>(<span>self, setup_params:Â List[Tuple[]])</span>
</code></dt>
<dd>
<div class="desc"><p>Update the simulation setup parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>setup_params</code></strong></dt>
<dd>List containing the desired input tuples for setup_fcn</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setParams(self, setup_params: List[Tuple]):
    &#34;&#34;&#34;
    Update the simulation setup parameters.

    Args:
        setup_params: List containing the desired input tuples for setup_fcn
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__setup_params = setup_params
    self.displacement_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))
    self.time_result = multiprocessing.Array(&#39;d&#39;, len(setup_params))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="voxelfuse.simulation.Simulation"><code class="flex name class">
<span>class <span class="ident">Simulation</span></span>
<span>(</span><span>voxel_model, id_number:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulation object that stores a VoxelModel and its associated simulation settings.</p>
<p>Initialize a Simulation object with default settings.</p>
<p>Models located at positive coordinate values will have their workspace
size adjusted to maintain their position in the exported simulation.
Models located at negative coordinate values will be shifted to the origin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxel_model</code></strong></dt>
<dd>VoxelModel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulation:
    &#34;&#34;&#34;
    Simulation object that stores a VoxelModel and its associated simulation settings.
    &#34;&#34;&#34;

    def __init__(self, voxel_model, id_number: int = 0):
        &#34;&#34;&#34;
        Initialize a Simulation object with default settings.

        Models located at positive coordinate values will have their workspace
        size adjusted to maintain their position in the exported simulation.
        Models located at negative coordinate values will be shifted to the origin.

        Args:
            voxel_model: VoxelModel
        &#34;&#34;&#34;
        # Simulation ID and start date
        self.id = id_number
        self.date = date.today()

        # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
        self.__model = ((VoxelModel.copy(voxel_model).fitWorkspace()) | empty(num_materials=(voxel_model.materials.shape[1] - 1), resolution=voxel_model.resolution)).removeDuplicateMaterials()

        # Simulator ##############
        # Integration
        self.__integrator = 0
        self.__dtFraction = 1.0

        # Damping
        self.__dampingBond = 1.0 # (0-1) Bulk material damping
        self.__dampingEnvironment = 0.0001 # (0-0.1) Damping caused by fluid environment

        # Collisions
        self.__collisionEnable = False
        self.__collisionDamping = 1.0 # (0-2) Elastic vs inelastic conditions
        self.__collisionSystem = 3
        self.__collisionHorizon = 3

        # Features
        self.__blendingEnable = False
        self.__xMixRadius = 0
        self.__yMixRadius = 0
        self.__zMixRadius = 0
        self.__blendingModel = 0
        self.__polyExp = 1
        self.__volumeEffectsEnable = False
        self.__hydrogelModelEnable = False

        # Stop conditions
        self.__stopConditionType = StopCondition.NONE
        self.__stopConditionValue = 0.0

        # Equilibrium mode
        self.__equilibriumModeEnable = False

        # Environment ############
        # Boundary conditions
        self.__bcRegions = []

        # Gravity
        self.__gravityEnable = True
        self.__gravityValue = -9.81
        self.__floorEnable = True

        # Thermal
        self.__temperatureEnable = False
        self.__temperatureBaseValue = 25.0
        self.__temperatureVaryEnable = False
        self.__temperatureVaryAmplitude = 0.0
        self.__temperatureVaryPeriod = 0.0
        self.__temperatureVaryOffset = 0.0
        self.__growthAmplitude = 0.0

        # Sensors #######
        self.__sensors = []

        # Temperature Controls #######
        self.__currentTempControlGroup = 0
        self.__localTempControls = []

        # Disconnected Bonds #######
        self.__disconnections = []

        # Results ################
        self.results = []
        self.valueMap = np.zeros_like(voxel_model.voxels, dtype=np.float32)

    @classmethod
    def copy(cls, simulation):
        &#34;&#34;&#34;
        Create new Simulation object with the same settings as an existing Simulation object.

        Args:
            simulation: Simulation to copy
        
        Returns:
            Simulation
        &#34;&#34;&#34;
        # Create new simulation object and copy attribute values
        new_simulation = cls(simulation.__model)
        new_simulation.__dict__ = simulation.__dict__.copy()

        # Update ID and date
        new_simulation.id = simulation.id + 1
        new_simulation.date = date.today()

        # Make lists copies instead of references
        new_simulation.__bcRegions = simulation.__bcRegions.copy()
        new_simulation.__sensors = simulation.__sensors.copy()
        new_simulation.__localTempControls = simulation.__localTempControls.copy()
        new_simulation.__disconnections = simulation.__disconnections.copy()
        new_simulation.results = simulation.results.copy()
        new_simulation.valueMap = simulation.valueMap.copy()

        return new_simulation

    # Configure settings ##################################
    def setModel(self, voxel_model):
        &#34;&#34;&#34;
        Set the model for a simulation.

        Models located at positive coordinate values will have their workspace
        size adjusted to maintain their position in the exported simulation.
        Models located at negative coordinate values will be shifted to the origin.

        Args:
            voxel_model: VoxelModel
        
        Returns:
            None
        &#34;&#34;&#34;
        # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
        self.__model = ((VoxelModel.copy(voxel_model).fitWorkspace()) | empty(num_materials=(voxel_model.materials.shape[1] - 1))).removeDuplicateMaterials()

    def setDamping(self, bond: float = 1.0, environment: float = 0.0001):
        &#34;&#34;&#34;
        Set simulation damping parameters.

        Environment damping can be used to simulate fluid environments. 0 represents
        a vacuum and larger values represent a viscous fluid.

        Args:
            bond: Voxel bond damping (0-1)
            environment: Environment damping (0-0.1)
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__dampingBond = bond
        self.__dampingEnvironment = environment

    def setCollision(self, enable: bool = True, damping: float = 1.0):
        &#34;&#34;&#34;
        Set simulation collision parameters.

        A damping value of 0 represents completely elastic collisions and
        higher values represent inelastic collisions.

        Args:
            enable: Enable/disable collisions
            damping: Collision damping (0-2)
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__collisionEnable = enable
        self.__collisionDamping = damping

    def setHydrogelModel(self, enable: bool = True):
        &#34;&#34;&#34;
        Set hydrogel model parameters.

        Args:
            enable: Enable/disable hydrogel model
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__hydrogelModelEnable = enable

    def setStopCondition(self, condition: StopCondition = StopCondition.NONE, value: float = 0):
        &#34;&#34;&#34;
        Set simulation stop condition.

        Args:
            condition: Stop condition type, set using StopCondition class
            value: Stop condition value
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__stopConditionType = condition
        self.__stopConditionValue = value

    def setEquilibriumMode(self, enable: bool = True):
        &#34;&#34;&#34;
        Set simulation equilibrium mode.

        Args:
            enable: Enable/disable equilibrium mode
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__equilibriumModeEnable = enable

    def setGravity(self, enable: bool = True, value: float = -9.81, enable_floor: bool = True):
        &#34;&#34;&#34;
        Set simulation gravity parameters.

        Args:
            enable: Enable/disable gravity
            value: Acceleration due to gravity in m/sec^2
            enable_floor: Enable/disable ground plane
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__gravityEnable = enable
        self.__gravityValue = value
        self.__floorEnable = enable_floor

    def setFixedThermal(self, enable: bool = True, base_temp: float = 25.0, growth_amplitude: float = 0.0):
        &#34;&#34;&#34;
        Set a fixed environment temperature.

        Args:
            enable: Enable/disable temperature
            base_temp: Temperature in degrees C
            growth_amplitude: Set to 1 to enable expansion from base size
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__temperatureEnable = enable
        self.__temperatureBaseValue = base_temp
        self.__temperatureVaryEnable = False
        self.__growthAmplitude = growth_amplitude

    def setVaryingThermal(self, enable: bool = True, base_temp: float = 25.0, amplitude: float = 0.0, period: float = 1.0, offset: float = 0.0, growth_amplitude: float = 1.0):
        &#34;&#34;&#34;
        Set a varying environment temperature.


        Args:
            enable: Enable/disable temperature
            base_temp: Base temperature in degrees C
            amplitude: Temperature fluctuation amplitude
            period: Temperature fluctuation period
            offset: Temperature offset (not currently supported)
            growth_amplitude: Set to 1 to enable expansion from base size
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__temperatureEnable = enable
        self.__temperatureBaseValue = base_temp
        self.__temperatureVaryEnable = enable
        self.__temperatureVaryAmplitude = amplitude
        self.__temperatureVaryPeriod = period
        self.__temperatureVaryOffset = offset
        self.__growthAmplitude = growth_amplitude

    # Read settings ##################################
    def getModel(self):
        &#34;&#34;&#34;
        Get the simulation model.
        
        Returns:
            VoxelModel
        &#34;&#34;&#34;
        return self.__model

    def getVoxelDim(self):
        &#34;&#34;&#34;
        Get the side dimension of a voxel in mm.
        
        Returns:
            Float
        &#34;&#34;&#34;
        res = self.__model.resolution
        return (1.0/res) * 0.001

    def getDamping(self):
        &#34;&#34;&#34;
        Get simulation damping parameters.
        
        Returns:
            Voxel bond damping, Environment damping
        &#34;&#34;&#34;
        return self.__dampingBond, self.__dampingEnvironment

    def getCollision(self):
        &#34;&#34;&#34;
        Get simulation collision parameters.
        
        Returns:
            Enable/disable collisions, Collision damping
        &#34;&#34;&#34;
        return self.__collisionEnable, self.__collisionDamping

    def getHydrogelModel(self):
        &#34;&#34;&#34;
        Get hydrogel model parameters.
        
        Returns:
            Enable/disable hydrogel model
        &#34;&#34;&#34;
        return self.__hydrogelModelEnable

    def getStopCondition(self):
        &#34;&#34;&#34;
        Get simulation stop condition.
        
        Returns:
            Stop condition type, Stop condition value
        &#34;&#34;&#34;
        return self.__stopConditionType, self.__stopConditionValue

    def getEquilibriumMode(self):
        &#34;&#34;&#34;
        Get simulation equilibrium mode.
        
        Returns:
            Enable/disable equilibrium mode
        &#34;&#34;&#34;
        return self.__equilibriumModeEnable

    def getGravity(self):
        &#34;&#34;&#34;
        Get simulation gravity parameters.
        
        Returns:
            Enable/disable gravity, Acceleration due to gravity in m/sec^2, Enable/disable ground plane
        &#34;&#34;&#34;
        return self.__gravityEnable, self.__gravityValue, self.__floorEnable

    def getThermal(self):
        &#34;&#34;&#34;
        Get simulation temperature parameters.
        
        Returns:
            Enable/disable temperature, Base temperature in degrees C, Enable/disable temperature fluctuation, Temperature fluctuation amplitude, Temperature fluctuation period, Temperature offset
        &#34;&#34;&#34;
        return self.__temperatureEnable, self.__temperatureBaseValue, self.__temperatureVaryEnable, self.__temperatureVaryAmplitude, self.__temperatureVaryPeriod, self.__temperatureVaryOffset

    # Add forces, constraints, and sensors ##################################
    # Boundary condition sizes and positions are expressed as percentages of the overall model size
    #   radius is a percentage of the largest model dimension
    # Fixed DOF bits correspond to: Rz, Ry, Rx, Z, Y, X
    #   0: Free, force will be applied
    #   1: Fixed, displacement will be applied
    # Displacement is expressed in mm

    def clearBoundaryConditions(self):
        &#34;&#34;&#34;
        Remove all boundary conditions from a Simulation object.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__bcRegions = []
        # self.__bcVoxels = []

    # Default box boundary condition is a fixed constraint in the YZ plane
    def addBoundaryConditionVoxel(self, position: Tuple[int, int, int] = (0, 0, 0),
                                  fixed_dof: int = 0b111111,
                                  force: Tuple[float, float, float] = (0, 0, 0),
                                  displacement: Tuple[float, float, float] = (0, 0, 0),
                                  torque: Tuple[float, float, float] = (0, 0, 0),
                                  angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                  name: str = None):
        &#34;&#34;&#34;
        Add a boundary condition at a specific voxel.

        The fixed DOF value should be set as a 6-bit binary value (e.g. 0b111111) and the bits
        correspond to: Rz, Ry, Rx, Z, Y, X. If a bit is set to 0, the corresponding force/torque
        will be applied. If a bit is set to 1, the DOF will be fixed and the displacement will be
        applied.

        Args:
            position: Position in voxels
            fixed_dof: Fixed degrees of freedom
            force: Force vector in N
            displacement: Displacement vector in mm
            torque: Torque values in Nm
            angular_displacement: Angular displacement values in deg
            name: Boundary condition name
        
        Returns:
            None
        &#34;&#34;&#34;
        x = position[0] - self.__model.coords[0]
        y = position[1] - self.__model.coords[1]
        z = position[2] - self.__model.coords[2]

        x_len = int(self.__model.voxels.shape[0])
        y_len = int(self.__model.voxels.shape[1])
        z_len = int(self.__model.voxels.shape[2])

        pos = ((x+0.5)/x_len, (y+0.5)/y_len, (z+0.5)/z_len)
        radius = 0.49/x_len

        bc = _BCRegion(name, BCShape.SPHERE, pos, (0.0, 0.0, 0.0), radius, fixed_dof, force, displacement, torque, angular_displacement)
        self.__bcRegions.append(bc)

    # Default box boundary condition is a fixed constraint in the XY plane (bottom layer)
    def addBoundaryConditionBox(self, position: Tuple[float, float, float] = (0.0, 0.0, 0.0),
                                size: Tuple[float, float, float] = (1.0, 1.0, 0.01),
                                fixed_dof: int = 0b111111,
                                force: Tuple[float, float, float] = (0, 0, 0),
                                displacement: Tuple[float, float, float] = (0, 0, 0),
                                torque: Tuple[float, float, float] = (0, 0, 0),
                                angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                name: str = None):
        &#34;&#34;&#34;
        Add a box-shaped boundary condition.

        Boundary condition position and size are expressed as percentages of the
        overall model size. The fixed DOF value should be set as a 6-bit binary
        value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
        If a bit is set to 0, the corresponding force/torque will be applied. If
        a bit is set to 1, the DOF will be fixed and the displacement will be
        applied.

        Args:
            position: Box corner position (0-1)
            size: Box size (0-1)
            fixed_dof: Fixed degrees of freedom
            force: Force vector in N
            displacement: Displacement vector in mm
            torque: Torque values in Nm
            angular_displacement: Angular displacement values in deg
            name: Boundary condition name
        
        Returns:
            None
        &#34;&#34;&#34;
        bc = _BCRegion(name, BCShape.BOX, position, size, 0, fixed_dof, force, displacement, torque, angular_displacement)
        self.__bcRegions.append(bc)

    # Default sphere boundary condition is a fixed constraint centered in the model
    def addBoundaryConditionSphere(self, position: Tuple[float, float, float] = (0.5, 0.5, 0.5),
                                   radius: float = 0.05,
                                   fixed_dof: int = 0b111111,
                                   force: Tuple[float, float, float] = (0, 0, 0),
                                   displacement: Tuple[float, float, float] = (0, 0, 0),
                                   torque: Tuple[float, float, float] = (0, 0, 0),
                                   angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                   name: str = None):
        &#34;&#34;&#34;
        Add a spherical boundary condition.

        Boundary condition position and radius are expressed as percentages of the
        overall model size. The fixed DOF value should be set as a 6-bit binary
        value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
        If a bit is set to 0, the corresponding force/torque will be applied. If
        a bit is set to 1, the DOF will be fixed and the displacement will be
        applied.

        Args:
            position: Sphere center position (0-1)
            radius: Sphere radius (0-1)
            fixed_dof: Fixed degrees of freedom
            force: Force vector in N
            displacement: Displacement vector in mm
            torque: Torque values in Nm
            angular_displacement: Angular displacement values in deg
            name: Boundary condition name
        
        Returns:
            None
        &#34;&#34;&#34;
        bc = _BCRegion(name, BCShape.SPHERE, position, (0.0, 0.0, 0.0), radius, fixed_dof, force, displacement, torque, angular_displacement)
        self.__bcRegions.append(bc)

    # Default cylinder boundary condition is a fixed constraint centered in the model
    def addBoundaryConditionCylinder(self, position: Tuple[float, float, float] = (0.45, 0.5, 0.5), axis: Axis = Axis.X,
                                     height: float = 0.1,
                                     radius: float = 0.05,
                                     fixed_dof: int = 0b111111,
                                     force: Tuple[float, float, float] = (0, 0, 0),
                                     displacement: Tuple[float, float, float] = (0, 0, 0),
                                     torque: Tuple[float, float, float] = (0, 0, 0),
                                     angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                     name: str = None):
        &#34;&#34;&#34;
        Add a cylindrical boundary condition.

        Boundary condition position and size are expressed as percentages of the
        overall model size. The fixed DOF value should be set as a 6-bit binary
        value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
        If a bit is set to 0, the corresponding force/torque will be applied. If
        a bit is set to 1, the DOF will be fixed and the displacement will be
        applied.

        Args:
            position: Boundary condition origin position (0-1)
            axis: Cylinder axis (0-2)
            height: Cylinder height (0-1)
            radius: Cylinder radius (0-1)
            fixed_dof: Fixed degrees of freedom
            force: Force vector in N
            displacement: Displacement vector in mm
            torque: Torque values in Nm
            angular_displacement: Angular displacement values in deg
            name: Boundary condition name
        
        Returns:
            None
        &#34;&#34;&#34;
        size = [0.0, 0.0, 0.0]
        size[axis.value] = height
        bc = _BCRegion(name, BCShape.CYLINDER, position, (size[0], size[1], size[2]), radius, fixed_dof, force, displacement, torque, angular_displacement)
        self.__bcRegions.append(bc)

    def clearSensors(self):
        &#34;&#34;&#34;
        Remove all sensors from a Simulation object.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__sensors = []

    def addSensor(self, location: Tuple[int, int, int] = (0, 0, 0), axis: Axis = Axis.NONE, name: str = None): # TODO: Make Voxelyze use axis parameter
        &#34;&#34;&#34;
        Add a sensor to a voxel.

        Args:
            location: Sensor location in voxels
            axis: Sensor measurement axis
            name: Sensor name
        
        Returns:
            None
        &#34;&#34;&#34;
        x = location[0] - self.__model.coords[0]
        y = location[1] - self.__model.coords[1]
        z = location[2] - self.__model.coords[2]

        sensor = _Sensor(name, (x, y, z), axis)
        self.__sensors.append(sensor)

        if not self.__model.isOccupied((x, y, z)):
            print(&#39;WARNING: No material present at sensor voxel &#39; + str((x, y, z)))

    def clearDisconnections(self):
        &#34;&#34;&#34;
        Clear all disconnected voxel bonds.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__disconnections = []

    def addDisconnection(self, voxel_1: Tuple[int, int, int], voxel_2: Tuple[int, int, int]):
        &#34;&#34;&#34;
        Specify a pair of voxels which should be disconnected

        Args:
            voxel_1: Coordinates in voxels
            voxel_2: Coordinates in voxels
        
        Returns:
            None
        &#34;&#34;&#34;
        dc = _Disconnection(voxel_1, voxel_2)
        self.__disconnections.append(dc)

    def addTempControlGroup(self, locations: List[Tuple[int, int, int]] = None, name: str = None):
        &#34;&#34;&#34;
        Add a new temperature control group and select it.

        Args:
            locations: Control element locations in voxels as a list of tuples
            name: Group name
        
        Returns:
            None
        &#34;&#34;&#34;
        # Enable temperature control
        self.__temperatureEnable = True
        self.__temperatureVaryEnable = True

        if locations is None:
            print(&#39;No locations provided - applying temperature control group to entire model&#39;)

            x_len = self.__model.voxels.shape[0]
            y_len = self.__model.voxels.shape[1]
            z_len = self.__model.voxels.shape[2]

            locations = []
            for x in range(x_len):
                for y in range(y_len):
                    for z in range(z_len):
                        locations.append((x, y, z))

        group = _TempControlGroup(name, locations, [])
        self.__localTempControls.append(group)
        self.__currentTempControlGroup = len(self.__localTempControls)-1

    def removeTempControlGroup(self, index: int = 0):
        &#34;&#34;&#34;
        Remove a temperature control group by index.

        Args:
            index: Temperature control group index
        
        Returns:
            Name of removed group
        &#34;&#34;&#34;
        group = self.__localTempControls.pop(index)
        self.__currentTempControlGroup = len(self.__localTempControls)-1
        return group.name

    def selectTempControlGroup(self, index: int = 0):
        &#34;&#34;&#34;
        Select which keyframe new temperature control elements should be added to.

        Args:
            index: Temperature control group index
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__currentTempControlGroup = index

    def clearTempControlGroups(self):
        &#34;&#34;&#34;
        Clear all temperature control groups.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.__currentTempControlGroup = 0
        self.__localTempControls = []

    def cleanTempControlGroups(self):
        &#34;&#34;&#34;
        Remove invalid temperature control groups.

        Invalid groups have no keyframes, or have no target voxels.
        
        Returns:
            Number of groups removed
        &#34;&#34;&#34;
        removed_groups = []
        for g in range(len(self.__localTempControls)):
            g = g - len(removed_groups)
            group = self.__localTempControls[g]
            if len(group.keyframes) == 0 or len(group.locations) == 0:
                removed_groups.append(self.removeTempControlGroup(g))

        self.__currentTempControlGroup = len(self.__localTempControls)-1

        named_groups = []
        for n in removed_groups:
            if n is not None:
                named_groups.append(n)

        if len(removed_groups) == 0:
            pass
        elif len(named_groups) == 0:
            print(&#39;Removed &#39; + str(len(removed_groups)) + &#39; temperature control groups&#39;)
        else:
            print(&#39;Removed &#39; + str(len(removed_groups)) + &#39; temperature control groups, including: &#39; + str(named_groups))

        return len(removed_groups)

    def clearKeyframes(self):
        &#34;&#34;&#34;
        Remove all keyframes assigned to the current temperature control group.
        
        Returns:
            None
        &#34;&#34;&#34;
        g = self.__currentTempControlGroup
        self.__localTempControls[g].keyframes = []

    def addKeyframe(self, time_value: float = 0, amplitude_pos: float = 0, amplitude_neg: float = -1, percent_pos: float = 0.5,
                    period: float = 1.0, phase_offset: float = 0, temp_offset: float = 0, const_temp: bool = False, square_wave: bool = False):
        &#34;&#34;&#34;
        Add a keyframe to a temperature control group.

        Args:
            time_value: Time at which keyframe should take effect (sec)
            amplitude_pos: Control element positive temperature amplitude (deg C)
            amplitude_neg: Control element negative temperature amplitude (deg C)
            percent_pos: Percent of period spanned by positive temperature amplitude (0-1)
            period: Period of the control signal (sec)
            phase_offset: Control element phase offset for time-varying thermal (rad)
            temp_offset: Control element temperature offset for time-varying thermal (deg C)
            const_temp: Enable/disable setting a constant target temperature that respects heating/cooling rates
            square_wave: Enable/disable converting signal to a square wave (positive -&gt; a = amplitude1, negative -&gt; a = 0)
        
        Returns:
            None
        &#34;&#34;&#34;
        amplitude_pos = max(amplitude_pos, 0) # amplitude_pos must be positive

        if amplitude_neg &lt; 0: # If amplitude neg is not given (or not negative) use amplitude_pos instead
            amplitude_neg = amplitude_pos

        g = self.__currentTempControlGroup
        kf = _Keyframe(time_value, amplitude_pos, amplitude_neg, percent_pos, period, phase_offset, temp_offset, const_temp, square_wave)
        self.__localTempControls[g].keyframes.append(kf)

    def initializeTempMap(self):
        &#34;&#34;&#34;
        Initialize temperature control groups to which keyframes will be stored when using applyTempMap.
        
        Returns:
            None
        &#34;&#34;&#34;
        # Clear any existing temperature controls
        self.clearTempControlGroups()

        # Get map size
        x_len = self.__model.voxels.shape[0]
        y_len = self.__model.voxels.shape[1]
        z_len = self.__model.voxels.shape[2]

        # Generate empty control element for each voxel
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    self.addTempControlGroup([(x, y, z)])

    def applyTempMap(self, time_value, amp_pos_map, amp_neg_map=None, percent_pos_map=None, period_map=None,
                     phase_map=None, offset_map=None, const_temp_map=None, square_wave_map=None):
        &#34;&#34;&#34;
        Set the simulation temperature control elements based on a value maps of target temperature settings.

        This function relies on the temperature control groups being in a specific order. initializeTempMap should be called prior to running this function.

        Args:
            time_value: Time at which keyframe should take effect (sec)
            amp_pos_map: Array of target positive temperature amplitudes for each voxel (deg C)
            amp_neg_map: Array of target negative temperature amplitudes for each voxel (deg C)
            percent_pos_map: Array containing percent of period spanned by positive temperature amplitude for each voxel
            period_map: Array of signal periods for each voxel (sec)
            phase_map: Array of phase offsets for each voxel (rad)
            offset_map: Array of temperature offsets for each voxel (deg C)
            const_temp_map: Array of boolean values to enable/disable constant temperature mode
            square_wave_map: Array of boolean values to enable/disable square wave mode
        
        Returns:
            None
        &#34;&#34;&#34;
        # Get map size
        x_len = amp_pos_map.shape[0]
        y_len = amp_pos_map.shape[1]
        z_len = amp_pos_map.shape[2]

        # Generate the control element for each voxel
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    if abs(amp_pos_map[x, y, z]) &gt; FLOATING_ERROR or ((amp_neg_map is not None) and (abs(amp_neg_map[x, y, z]) &gt; FLOATING_ERROR)):  # If voxel is not empty
                        amplitude_pos = amp_pos_map[x, y, z]

                        if amp_neg_map is None:
                            amplitude_neg = amp_pos_map[x, y, z]
                        else:
                            amplitude_neg = amp_neg_map[x, y, z]

                        if percent_pos_map is None:
                            percent_pos = 0.5
                        else:
                            percent_pos = percent_pos_map[x, y, z]

                        if period_map is None:
                            period = 1.0
                        else:
                            period = period_map[x, y, z]

                        if phase_map is None:
                            phase_offset = 0
                        else:
                            phase_offset = phase_map[x, y, z]

                        if offset_map is None:
                            temp_offset = 0
                        else:
                            temp_offset = offset_map[x, y, z]

                        if const_temp_map is None:
                            const_temp = False
                        else:
                            const_temp = const_temp_map[x, y, z]

                        if square_wave_map is None:
                            square_wave = False
                        else:
                            square_wave = square_wave_map[x, y, z]

                        kf = _Keyframe(time_value, amplitude_pos, amplitude_neg, percent_pos, period, phase_offset, temp_offset, const_temp, square_wave)
                        g = z + y*z_len + x*y_len*z_len
                        self.__localTempControls[g].keyframes.append(kf)

    # Export simulation ##################################
    # Export simulation object to .vxa file for import into VoxCad or Voxelyze
    def saveVXA(self, filename: str, compression: bool = False):
        &#34;&#34;&#34;
        Save model data to a .vxa file

        The VoxCad simulation file format stores all the data contained in
        a .vxc file (geometry, material palette) plus the simulation setup (simulation
        parameters, environment settings, boundary conditions).

        This format supports compression for the voxel data. Enabling compression allows
        for larger models, but it may introduce geometry errors that particularly affect
        small models.

        The .vxa file type can be opened using VoxCad simulation software. However, it
        cannot currently be reopened by a VoxelFuse script.

        Args:
            filename: File name
            compression: Enable/disable voxel data compression
        
        Returns:
            None
        &#34;&#34;&#34;
        self.cleanTempControlGroups()
        f = open(filename + &#39;.vxa&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        writeHeader(f, &#39;1.0&#39;, &#39;ISO-8859-1&#39;)
        writeOpen(f, &#39;VXA Version=&#34;&#39; + str(1.1) + &#39;&#34;&#39;, 0)
        self.writeSimData(f)
        self.writeEnvironmentData(f)
        self.writeSensors(f)
        self.writeTempControls(f)
        self.writeDisconnections(f)
        self.__model.writeVXCData(f, compression)
        writeClos(f, &#39;VXA&#39;, 0)
        f.close()

    # Write simulator settings to file
    def writeSimData(self, f: TextIO):
        &#34;&#34;&#34;
        Write simulation parameters to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        # Simulator settings
        writeOpen(f, &#39;Simulator&#39;, 0)
        writeOpen(f, &#39;Integration&#39;, 1)
        writeData(f, &#39;Integrator&#39;, self.__integrator, 2)
        writeData(f, &#39;DtFrac&#39;, self.__dtFraction, 2)
        writeClos(f, &#39;Integration&#39;, 1)

        writeOpen(f, &#39;Damping&#39;, 1)
        writeData(f, &#39;BondDampingZ&#39;, self.__dampingBond, 2)
        writeData(f, &#39;ColDampingZ&#39;, self.__collisionDamping, 2)
        writeData(f, &#39;SlowDampingZ&#39;, self.__dampingEnvironment, 2)
        writeClos(f, &#39;Damping&#39;, 1)

        writeOpen(f, &#39;Collisions&#39;, 1)
        writeData(f, &#39;SelfColEnabled&#39;, int(self.__collisionEnable), 2)
        writeData(f, &#39;ColSystem&#39;, self.__collisionSystem, 2)
        writeData(f, &#39;CollisionHorizon&#39;, self.__collisionHorizon, 2)
        writeClos(f, &#39;Collisions&#39;, 1)

        writeOpen(f, &#39;Features&#39;, 1)
        writeData(f, &#39;BlendingEnabled&#39;, int(self.__blendingEnable), 2)
        writeData(f, &#39;XMixRadius&#39;, self.__xMixRadius, 2)
        writeData(f, &#39;YMixRadius&#39;, self.__yMixRadius, 2)
        writeData(f, &#39;ZMixRadius&#39;, self.__zMixRadius, 2)
        writeData(f, &#39;BlendModel&#39;, self.__blendingModel, 2)
        writeData(f, &#39;PolyExp&#39;, self.__polyExp, 2)
        writeData(f, &#39;VolumeEffectsEnabled&#39;, int(self.__volumeEffectsEnable), 2)
        writeClos(f, &#39;Features&#39;, 1)

        writeOpen(f, &#39;StopCondition&#39;, 1)
        writeData(f, &#39;StopConditionType&#39;, self.__stopConditionType.value, 2)
        writeData(f, &#39;StopConditionValue&#39;, self.__stopConditionValue, 2)
        writeClos(f, &#39;StopCondition&#39;, 1)

        writeOpen(f, &#39;EquilibriumMode&#39;, 1)
        writeData(f, &#39;EquilibriumModeEnabled&#39;, int(self.__equilibriumModeEnable), 2)
        writeClos(f, &#39;EquilibriumMode&#39;, 1)
        writeClos(f, &#39;Simulator&#39;, 0)

    # Write environment settings to file
    def writeEnvironmentData(self, f: TextIO):
        &#34;&#34;&#34;
        Write simulation environment parameters to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        # Environment settings
        writeOpen(f, &#39;Environment&#39;, 0)
        writeOpen(f, &#39;Boundary_Conditions&#39;, 1)
        writeData(f, &#39;NumBCs&#39;, len(self.__bcRegions), 2)
        for bc in self.__bcRegions:
            writeOpen(f, &#39;FRegion&#39;, 2)
            if bc.name is not None:
                writeData(f, &#39;Name&#39;, bc.name, 3)
            writeData(f, &#39;PrimType&#39;, int(bc.shape.value), 3)
            writeData(f, &#39;X&#39;, bc.position[0], 3)
            writeData(f, &#39;Y&#39;, bc.position[1], 3)
            writeData(f, &#39;Z&#39;, bc.position[2], 3)
            writeData(f, &#39;dX&#39;, bc.size[0], 3)
            writeData(f, &#39;dY&#39;, bc.size[1], 3)
            writeData(f, &#39;dZ&#39;, bc.size[2], 3)
            writeData(f, &#39;Radius&#39;, bc.radius, 3)
            writeData(f, &#39;R&#39;, bc.color[0], 3)
            writeData(f, &#39;G&#39;, bc.color[1], 3)
            writeData(f, &#39;B&#39;, bc.color[2], 3)
            writeData(f, &#39;alpha&#39;, bc.color[3], 3)
            writeData(f, &#39;DofFixed&#39;, bc.fixed_dof, 3)
            writeData(f, &#39;ForceX&#39;, bc.force[0], 3)
            writeData(f, &#39;ForceY&#39;, bc.force[1], 3)
            writeData(f, &#39;ForceZ&#39;, bc.force[2], 3)
            writeData(f, &#39;TorqueX&#39;, bc.torque[0], 3)
            writeData(f, &#39;TorqueY&#39;, bc.torque[1], 3)
            writeData(f, &#39;TorqueZ&#39;, bc.torque[2], 3)
            writeData(f, &#39;DisplaceX&#39;, bc.displacement[0] * 1e-3, 3)
            writeData(f, &#39;DisplaceY&#39;, bc.displacement[1] * 1e-3, 3)
            writeData(f, &#39;DisplaceZ&#39;, bc.displacement[2] * 1e-3, 3)
            writeData(f, &#39;AngDisplaceX&#39;, bc.angular_displacement[0], 3)
            writeData(f, &#39;AngDisplaceY&#39;, bc.angular_displacement[1], 3)
            writeData(f, &#39;AngDisplaceZ&#39;, bc.angular_displacement[2], 3)
            writeClos(f, &#39;FRegion&#39;, 2)
        writeClos(f, &#39;Boundary_Conditions&#39;, 1)

        writeOpen(f, &#39;Gravity&#39;, 1)
        writeData(f, &#39;GravEnabled&#39;, int(self.__gravityEnable), 2)
        writeData(f, &#39;GravAcc&#39;, self.__gravityValue, 2)
        writeData(f, &#39;FloorEnabled&#39;, int(self.__floorEnable), 2)
        writeClos(f, &#39;Gravity&#39;, 1)

        writeOpen(f, &#39;Thermal&#39;, 1)
        writeData(f, &#39;TempEnabled&#39;, int(self.__temperatureEnable), 2)
        writeData(f, &#39;TempAmplitude&#39;, self.__temperatureVaryAmplitude, 2)
        writeData(f, &#39;TempBase&#39;, self.__temperatureBaseValue, 2)
        writeData(f, &#39;VaryTempEnabled&#39;, int(self.__temperatureVaryEnable), 2)
        writeData(f, &#39;TempPeriod&#39;, self.__temperatureVaryPeriod, 2)
        writeData(f, &#39;TempOffset&#39;, self.__temperatureVaryOffset, 2)
        writeClos(f, &#39;Thermal&#39;, 1)

        writeData(f, &#39;GrowthAmplitude&#39;, self.__growthAmplitude, 1)
        writeClos(f, &#39;Environment&#39;, 0)

    def writeSensors(self, f: TextIO):
        &#34;&#34;&#34;
        Write voxel sensors to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        writeOpen(f, &#39;Sensors&#39;, 0)
        for sensor in self.__sensors:
            writeOpen(f, &#39;Sensor&#39;, 1)
            if sensor.name is not None:
                writeData(f, &#39;Name&#39;, sensor.name, 2)
            writeData(f, &#39;Location&#39;, str(sensor.coords).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
            writeData(f, &#39;Axis&#39;, sensor.axis.value, 2)
            writeClos(f, &#39;Sensor&#39;, 1)
        writeClos(f, &#39;Sensors&#39;, 0)

    def writeTempControls(self, f: TextIO):
        &#34;&#34;&#34;
        Write temperature control element to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        writeData(f, &#39;EnableHydrogelModel&#39;, int(self.__hydrogelModelEnable), 0)

        writeOpen(f, &#39;TempControls&#39;, 0)
        for group in self.__localTempControls:
            writeOpen(f, &#39;Element&#39;, 1)

            if group.name is not None:
                writeData(f, &#39;Name&#39;, group.name, 2)

            writeOpen(f, &#39;Locations&#39;, 2)
            for loc in group.locations:
                writeData(f, &#39;Location&#39;, str(loc).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 3)
            writeClos(f, &#39;Locations&#39;, 2)

            writeOpen(f, &#39;Keyframes&#39;, 2)
            for keyframe in group.keyframes:
                writeOpen(f, &#39;Keyframe&#39;, 3)
                writeData(f, &#39;TimeValue&#39;, keyframe.time_value, 4)
                writeData(f, &#39;AmplitudePos&#39;, keyframe.amplitude_pos, 4)
                writeData(f, &#39;AmplitudeNeg&#39;, keyframe.amplitude_neg, 4)
                writeData(f, &#39;PercentPos&#39;, keyframe.percent_pos, 4)
                writeData(f, &#39;Period&#39;, keyframe.period, 4)
                writeData(f, &#39;PhaseOffset&#39;, keyframe.phase_offset, 4)
                writeData(f, &#39;TempOffset&#39;, keyframe.temp_offset, 4)
                writeData(f, &#39;ConstantTemp&#39;, int(keyframe.const_temp), 4)
                writeData(f, &#39;SquareWave&#39;, int(keyframe.square_wave), 4)
                writeClos(f, &#39;Keyframe&#39;, 3)
            writeClos(f, &#39;Keyframes&#39;, 2)

            writeClos(f, &#39;Element&#39;, 1)
        writeClos(f, &#39;TempControls&#39;, 0)

    def writeDisconnections(self, f: TextIO):
        &#34;&#34;&#34;
        Write bond disconnections to a text file using the .vxa format.

        Args:
            f: File to write to
        
        Returns:
            None
        &#34;&#34;&#34;
        writeOpen(f, &#39;Disconnections&#39;, 0)
        for dc in self.__disconnections:
            writeOpen(f, &#39;Break&#39;, 1)
            writeData(f, &#39;Voxel1&#39;, str(dc.vx1).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
            writeData(f, &#39;Voxel2&#39;, str(dc.vx2).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
            writeClos(f, &#39;Break&#39;, 1)
        writeClos(f, &#39;Disconnections&#39;, 0)

    def runSim(self, filename: str = &#39;temp&#39;, value_map: int = 0, delete_files: bool = True, log_interval: int = -1, history_interval: int = -1, voxelyze_on_path: bool = False, wsl: bool = False):
        &#34;&#34;&#34;
        Run a Simulation object using Voxelyze.

        This function will create a .vxa file, run the file with Voxelyze, and then load the .xml results file into
        the results attribute of the Simulation object. Enabling delete_files will delete both the .vxa and .xml files
        once the results have been loaded.

        History files can be viewed using https://github.com/voxcraft/voxcraft-viz

        Args:
            filename: File name for .vxa and .xml files
            value_map: Index of the desired value map type
            log_interval: Set the step interval at which sensor log entries should be recorded, -1 to disable log
            history_interval: Set the step interval at which history file entries should be recorded, -1 for default interval
            delete_files: Enable/disable deleting simulation file when process is complete
            voxelyze_on_path: Enable/disable using system Voxelyze rather than bundled Voxelyze
            wsl: Enable/disable using Windows Subsystem for Linux with bundled Voxelyze
        
        Returns:
            None
        &#34;&#34;&#34;
        # Generate results file/directory names
        filename = filename + &#39;_&#39; + str(self.id)
        dirname = &#39;sim_results_&#39; + str(self.date)

        # Create results directory
        if not os.path.exists(dirname):
            os.makedirs(dirname)

        # Create simulation file
        self.saveVXA(dirname + &#39;/&#39; + filename)

        if voxelyze_on_path:
            command_string = &#39;voxelyze&#39;
        else:
            # Check OS type
            if os.name.startswith(&#39;nt&#39;): # Windows
                if wsl:
                    command_string = &#39;wsl &#34;&#39; + os.path.dirname(os.path.realpath(__file__)).replace(&#39;C:&#39;, &#39;/mnt/c&#39;).replace(&#39;\\&#39;, &#39;/&#39;) + &#39;/utils/voxelyze&#34;&#39;
                else:
                    command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}\\utils\\voxelyze.exe&#34;&#39;
            else: # Linux
                command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}/utils/voxelyze&#34;&#39;

        command_string = command_string + &#39; -f &#39; + dirname + &#39;/&#39; + filename + &#39;.vxa -o &#39; + dirname + &#39;/&#39; + filename + &#39; -vm &#39; + str(value_map) + &#39; -p&#39;

        if log_interval &gt; 0:
            command_string = command_string + &#39; -log-interval &#39; + str(log_interval)

        if history_interval &gt; 0:
            command_string = command_string + &#39; -history-interval &#39; + str(history_interval)

        print(&#39;Launching Voxelyze using: &#39; + command_string)
        p = subprocess.Popen(command_string, shell=True)
        p.wait()

        # Open simulation results
        f = open(dirname + &#39;/&#39; + filename + &#39;.xml&#39;, &#39;r&#39;)
        #print(&#39;Opening file: &#39; + f.name)
        data = f.readlines()
        f.close()

        # Clear any previous results
        self.results = []

        # Find start and end locations for individual sensors
        startLoc = []
        endLoc = []
        for row in range(len(data)): # tqdm(range(len(data)), desc=&#39;Finding sensor tags&#39;):
            data[row] = data[row].replace(&#39;\t&#39;, &#39;&#39;)
            if data[row][:-1] == &#39;&lt;Sensor&gt;&#39;:
                startLoc.append(row)
            elif data[row][:-1] == &#39;&lt;/Sensor&gt;&#39;:
                endLoc.append(row)

        # Read the data from each sensor
        sensor_count = len(startLoc)
        if sensor_count &gt; 0:
            for sensor in range(sensor_count): # tqdm(range(len(startLoc)), desc=&#39;Reading sensor results&#39;):
                # Create a dictionary to hold the current sensor results
                sensorResults = {}

                # Read the data from each sensor tag
                for row in range(startLoc[sensor]+1, endLoc[sensor]):
                    # Determine the current tag
                    tag = &#39;&#39;
                    for col in range(1, len(data[row])):
                        if data[row][col] == &#39;&gt;&#39;:
                            tag = data[row][1:col]
                            break

                    # Remove the tags and newline to determine the current value
                    data[row] = data[row].replace(&#39;&lt;&#39;+tag+&#39;&gt;&#39;, &#39;&#39;).replace(&#39;&lt;/&#39;+tag+&#39;&gt;&#39;, &#39;&#39;)
                    value = data[row][:-1]

                    # Combine the current tag and value
                    if tag == &#39;Location&#39;:
                        coords =  tuple(map(int, value.split(&#39; &#39;)))
                        x = coords[0] + self.__model.coords[0]
                        y = coords[1] + self.__model.coords[1]
                        z = coords[2] + self.__model.coords[2]
                        currentResult = {tag:(x, y, z)}
                    elif &#39; &#39; in value:
                        currentResult = {tag:tuple(map(float, value.split(&#39; &#39;)))}
                    else:
                        currentResult = {tag:float(value)}

                    # Add the current tag and value to the sensor results dictionary
                    sensorResults.update(currentResult)

                # Append the results dictionary for the current sensor to the simulation results list
                self.results.append(sensorResults)
        else:
            print(&#39;No sensors found&#39;)

        if os.path.exists(&#39;value_map.txt&#39;):
            # Open simulation value map results
            f = open(&#39;value_map.txt&#39;, &#39;r&#39;)
            print(&#39;Opening file: &#39; + f.name)
            data = f.readlines()
            f.close()

            # Clear any previous results
            self.valueMap = np.zeros_like(self.__model.voxels, dtype=np.float32)

            # Get map size
            x_len = self.valueMap.shape[0]
            y_len = self.valueMap.shape[1]
            z_len = self.valueMap.shape[2]

            for z in range(z_len): # tqdm(range(z_len), desc=&#39;Loading layers&#39;):
                vals = np.array(data[z][:-2].split(&#34;,&#34;), dtype=np.float32)
                for y in range(y_len):
                    self.valueMap[:, y, z] = vals[y*x_len:(y+1)*x_len]

        # Remove temporary files
        if delete_files:
            os.remove(dirname + &#39;/&#39; + filename + &#39;.vxa&#39;)
            os.remove(dirname + &#39;/&#39; + filename + &#39;.xml&#39;)

            if os.path.exists(dirname + &#39;/value_map.txt&#39;):
                os.remove(dirname + &#39;/value_map.txt&#39;)

    def runSimVoxCad(self, filename: str = &#39;temp&#39;, delete_files: bool = True, voxcad_on_path: bool = False, wsl: bool = False):
        &#34;&#34;&#34;
        Run a Simulation object using the VoxCad GUI.

        ----

        Example:

        ``simulation = Simulation(modelResult)``

        ``simulation.setCollision()``

        ``simulation.setStopCondition(StopCondition.TIME_VALUE, 0.01)``

        ``simulation.runSimVoxCad(&#39;collision_sim_1&#39;, delete_files=False)``

        ----

        Args:
            filename: File name
            delete_files: Enable/disable deleting simulation file when VoxCad is closed
            voxcad_on_path: Enable/disable using system VoxCad rather than bundled VoxCad
            wsl: Enable/disable using Windows Subsystem for Linux with bundled VoxCad
        
        Returns:
            None
        &#34;&#34;&#34;
        # Generate file name
        filename = filename + &#39;_&#39; + str(self.id)

        # Create simulation file
        self.saveVXA(filename)

        if voxcad_on_path:
            command_string = &#39;voxcad &#39;
        else:
            # Check OS type
            if os.name.startswith(&#39;nt&#39;): # Windows
                if wsl:
                    command_string = &#39;wsl &#34;&#39; + os.path.dirname(os.path.realpath(__file__)).replace(&#39;C:&#39;, &#39;/mnt/c&#39;).replace(&#39;\\&#39;, &#39;/&#39;) + &#39;/utils/VoxCad&#34; &#39;
                else:
                    command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}\\utils\\VoxCad.exe&#34; &#39;
            else: # Linux
                command_string =  f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}/utils/VoxCad&#34; &#39;

        command_string = command_string + filename + &#39;.vxa&#39;

        print(&#39;Launching VoxCad using: &#39; + command_string)
        p = subprocess.Popen(command_string, shell=True)
        p.wait()

        if delete_files:
            print(&#39;Removing file: &#39; + filename + &#39;.vxa&#39;)
            os.remove(filename + &#39;.vxa&#39;)

    def saveResults(self, filename):
        &#34;&#34;&#34;
        Saves a simulation&#39;s results dictionary to a .csv file.

        Args:
            filename: Name of output file

        Returns:
            None
        &#34;&#34;&#34;
        # Get result table keys and size
        keys = list(self.results[0].keys())
        rows = len(self.results)
        cols = len(keys)

        # Create results file
        f = open(filename + &#39;.csv&#39;, &#39;w+&#39;)
        print(&#39;Saving file: &#39; + f.name)

        # Write headings
        f.write(&#39;Sensor&#39;)
        for c in range(cols):
            f.write(&#39;,&#39; + str(keys[c]))
        f.write(&#39;\n&#39;)

        # Write values
        for r in range(rows):
            f.write(str(r))
            vals = list(self.results[r].values())
            for c in range(cols):
                f.write(&#39;,&#39; + str(vals[c]).replace(&#39;,&#39;, &#39; &#39;))
            f.write(&#39;\n&#39;)

        # Close file
        f.close()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="voxelfuse.simulation.Simulation.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>simulation)</span>
</code></dt>
<dd>
<div class="desc"><p>Create new Simulation object with the same settings as an existing Simulation object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>simulation</code></strong></dt>
<dd>Simulation to copy</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def copy(cls, simulation):
    &#34;&#34;&#34;
    Create new Simulation object with the same settings as an existing Simulation object.

    Args:
        simulation: Simulation to copy
    
    Returns:
        Simulation
    &#34;&#34;&#34;
    # Create new simulation object and copy attribute values
    new_simulation = cls(simulation.__model)
    new_simulation.__dict__ = simulation.__dict__.copy()

    # Update ID and date
    new_simulation.id = simulation.id + 1
    new_simulation.date = date.today()

    # Make lists copies instead of references
    new_simulation.__bcRegions = simulation.__bcRegions.copy()
    new_simulation.__sensors = simulation.__sensors.copy()
    new_simulation.__localTempControls = simulation.__localTempControls.copy()
    new_simulation.__disconnections = simulation.__disconnections.copy()
    new_simulation.results = simulation.results.copy()
    new_simulation.valueMap = simulation.valueMap.copy()

    return new_simulation</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="voxelfuse.simulation.Simulation.addBoundaryConditionBox"><code class="name flex">
<span>def <span class="ident">addBoundaryConditionBox</span></span>(<span>self, position:Â Tuple[float,Â float,Â float]Â =Â (0.0, 0.0, 0.0), size:Â Tuple[float,Â float,Â float]Â =Â (1.0, 1.0, 0.01), fixed_dof:Â intÂ =Â 63, force:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), displacement:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), torque:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), angular_displacement:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a box-shaped boundary condition.</p>
<p>Boundary condition position and size are expressed as percentages of the
overall model size. The fixed DOF value should be set as a 6-bit binary
value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
If a bit is set to 0, the corresponding force/torque will be applied. If
a bit is set to 1, the DOF will be fixed and the displacement will be
applied.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>Box corner position (0-1)</dd>
<dt><strong><code>size</code></strong></dt>
<dd>Box size (0-1)</dd>
<dt><strong><code>fixed_dof</code></strong></dt>
<dd>Fixed degrees of freedom</dd>
<dt><strong><code>force</code></strong></dt>
<dd>Force vector in N</dd>
<dt><strong><code>displacement</code></strong></dt>
<dd>Displacement vector in mm</dd>
<dt><strong><code>torque</code></strong></dt>
<dd>Torque values in Nm</dd>
<dt><strong><code>angular_displacement</code></strong></dt>
<dd>Angular displacement values in deg</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Boundary condition name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addBoundaryConditionBox(self, position: Tuple[float, float, float] = (0.0, 0.0, 0.0),
                            size: Tuple[float, float, float] = (1.0, 1.0, 0.01),
                            fixed_dof: int = 0b111111,
                            force: Tuple[float, float, float] = (0, 0, 0),
                            displacement: Tuple[float, float, float] = (0, 0, 0),
                            torque: Tuple[float, float, float] = (0, 0, 0),
                            angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                            name: str = None):
    &#34;&#34;&#34;
    Add a box-shaped boundary condition.

    Boundary condition position and size are expressed as percentages of the
    overall model size. The fixed DOF value should be set as a 6-bit binary
    value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
    If a bit is set to 0, the corresponding force/torque will be applied. If
    a bit is set to 1, the DOF will be fixed and the displacement will be
    applied.

    Args:
        position: Box corner position (0-1)
        size: Box size (0-1)
        fixed_dof: Fixed degrees of freedom
        force: Force vector in N
        displacement: Displacement vector in mm
        torque: Torque values in Nm
        angular_displacement: Angular displacement values in deg
        name: Boundary condition name
    
    Returns:
        None
    &#34;&#34;&#34;
    bc = _BCRegion(name, BCShape.BOX, position, size, 0, fixed_dof, force, displacement, torque, angular_displacement)
    self.__bcRegions.append(bc)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.addBoundaryConditionCylinder"><code class="name flex">
<span>def <span class="ident">addBoundaryConditionCylinder</span></span>(<span>self, position:Â Tuple[float,Â float,Â float]Â =Â (0.45, 0.5, 0.5), axis:Â <a title="voxelfuse.simulation.Axis" href="#voxelfuse.simulation.Axis">Axis</a>Â =Â Axis.X, height:Â floatÂ =Â 0.1, radius:Â floatÂ =Â 0.05, fixed_dof:Â intÂ =Â 63, force:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), displacement:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), torque:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), angular_displacement:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a cylindrical boundary condition.</p>
<p>Boundary condition position and size are expressed as percentages of the
overall model size. The fixed DOF value should be set as a 6-bit binary
value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
If a bit is set to 0, the corresponding force/torque will be applied. If
a bit is set to 1, the DOF will be fixed and the displacement will be
applied.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>Boundary condition origin position (0-1)</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>Cylinder axis (0-2)</dd>
<dt><strong><code>height</code></strong></dt>
<dd>Cylinder height (0-1)</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Cylinder radius (0-1)</dd>
<dt><strong><code>fixed_dof</code></strong></dt>
<dd>Fixed degrees of freedom</dd>
<dt><strong><code>force</code></strong></dt>
<dd>Force vector in N</dd>
<dt><strong><code>displacement</code></strong></dt>
<dd>Displacement vector in mm</dd>
<dt><strong><code>torque</code></strong></dt>
<dd>Torque values in Nm</dd>
<dt><strong><code>angular_displacement</code></strong></dt>
<dd>Angular displacement values in deg</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Boundary condition name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addBoundaryConditionCylinder(self, position: Tuple[float, float, float] = (0.45, 0.5, 0.5), axis: Axis = Axis.X,
                                 height: float = 0.1,
                                 radius: float = 0.05,
                                 fixed_dof: int = 0b111111,
                                 force: Tuple[float, float, float] = (0, 0, 0),
                                 displacement: Tuple[float, float, float] = (0, 0, 0),
                                 torque: Tuple[float, float, float] = (0, 0, 0),
                                 angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                                 name: str = None):
    &#34;&#34;&#34;
    Add a cylindrical boundary condition.

    Boundary condition position and size are expressed as percentages of the
    overall model size. The fixed DOF value should be set as a 6-bit binary
    value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
    If a bit is set to 0, the corresponding force/torque will be applied. If
    a bit is set to 1, the DOF will be fixed and the displacement will be
    applied.

    Args:
        position: Boundary condition origin position (0-1)
        axis: Cylinder axis (0-2)
        height: Cylinder height (0-1)
        radius: Cylinder radius (0-1)
        fixed_dof: Fixed degrees of freedom
        force: Force vector in N
        displacement: Displacement vector in mm
        torque: Torque values in Nm
        angular_displacement: Angular displacement values in deg
        name: Boundary condition name
    
    Returns:
        None
    &#34;&#34;&#34;
    size = [0.0, 0.0, 0.0]
    size[axis.value] = height
    bc = _BCRegion(name, BCShape.CYLINDER, position, (size[0], size[1], size[2]), radius, fixed_dof, force, displacement, torque, angular_displacement)
    self.__bcRegions.append(bc)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.addBoundaryConditionSphere"><code class="name flex">
<span>def <span class="ident">addBoundaryConditionSphere</span></span>(<span>self, position:Â Tuple[float,Â float,Â float]Â =Â (0.5, 0.5, 0.5), radius:Â floatÂ =Â 0.05, fixed_dof:Â intÂ =Â 63, force:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), displacement:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), torque:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), angular_displacement:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a spherical boundary condition.</p>
<p>Boundary condition position and radius are expressed as percentages of the
overall model size. The fixed DOF value should be set as a 6-bit binary
value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
If a bit is set to 0, the corresponding force/torque will be applied. If
a bit is set to 1, the DOF will be fixed and the displacement will be
applied.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>Sphere center position (0-1)</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Sphere radius (0-1)</dd>
<dt><strong><code>fixed_dof</code></strong></dt>
<dd>Fixed degrees of freedom</dd>
<dt><strong><code>force</code></strong></dt>
<dd>Force vector in N</dd>
<dt><strong><code>displacement</code></strong></dt>
<dd>Displacement vector in mm</dd>
<dt><strong><code>torque</code></strong></dt>
<dd>Torque values in Nm</dd>
<dt><strong><code>angular_displacement</code></strong></dt>
<dd>Angular displacement values in deg</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Boundary condition name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addBoundaryConditionSphere(self, position: Tuple[float, float, float] = (0.5, 0.5, 0.5),
                               radius: float = 0.05,
                               fixed_dof: int = 0b111111,
                               force: Tuple[float, float, float] = (0, 0, 0),
                               displacement: Tuple[float, float, float] = (0, 0, 0),
                               torque: Tuple[float, float, float] = (0, 0, 0),
                               angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                               name: str = None):
    &#34;&#34;&#34;
    Add a spherical boundary condition.

    Boundary condition position and radius are expressed as percentages of the
    overall model size. The fixed DOF value should be set as a 6-bit binary
    value (e.g. 0b111111) and the bits correspond to: Rz, Ry, Rx, Z, Y, X.
    If a bit is set to 0, the corresponding force/torque will be applied. If
    a bit is set to 1, the DOF will be fixed and the displacement will be
    applied.

    Args:
        position: Sphere center position (0-1)
        radius: Sphere radius (0-1)
        fixed_dof: Fixed degrees of freedom
        force: Force vector in N
        displacement: Displacement vector in mm
        torque: Torque values in Nm
        angular_displacement: Angular displacement values in deg
        name: Boundary condition name
    
    Returns:
        None
    &#34;&#34;&#34;
    bc = _BCRegion(name, BCShape.SPHERE, position, (0.0, 0.0, 0.0), radius, fixed_dof, force, displacement, torque, angular_displacement)
    self.__bcRegions.append(bc)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.addBoundaryConditionVoxel"><code class="name flex">
<span>def <span class="ident">addBoundaryConditionVoxel</span></span>(<span>self, position:Â Tuple[int,Â int,Â int]Â =Â (0, 0, 0), fixed_dof:Â intÂ =Â 63, force:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), displacement:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), torque:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), angular_displacement:Â Tuple[float,Â float,Â float]Â =Â (0, 0, 0), name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a boundary condition at a specific voxel.</p>
<p>The fixed DOF value should be set as a 6-bit binary value (e.g. 0b111111) and the bits
correspond to: Rz, Ry, Rx, Z, Y, X. If a bit is set to 0, the corresponding force/torque
will be applied. If a bit is set to 1, the DOF will be fixed and the displacement will be
applied.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>Position in voxels</dd>
<dt><strong><code>fixed_dof</code></strong></dt>
<dd>Fixed degrees of freedom</dd>
<dt><strong><code>force</code></strong></dt>
<dd>Force vector in N</dd>
<dt><strong><code>displacement</code></strong></dt>
<dd>Displacement vector in mm</dd>
<dt><strong><code>torque</code></strong></dt>
<dd>Torque values in Nm</dd>
<dt><strong><code>angular_displacement</code></strong></dt>
<dd>Angular displacement values in deg</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Boundary condition name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addBoundaryConditionVoxel(self, position: Tuple[int, int, int] = (0, 0, 0),
                              fixed_dof: int = 0b111111,
                              force: Tuple[float, float, float] = (0, 0, 0),
                              displacement: Tuple[float, float, float] = (0, 0, 0),
                              torque: Tuple[float, float, float] = (0, 0, 0),
                              angular_displacement: Tuple[float, float, float] = (0, 0, 0),
                              name: str = None):
    &#34;&#34;&#34;
    Add a boundary condition at a specific voxel.

    The fixed DOF value should be set as a 6-bit binary value (e.g. 0b111111) and the bits
    correspond to: Rz, Ry, Rx, Z, Y, X. If a bit is set to 0, the corresponding force/torque
    will be applied. If a bit is set to 1, the DOF will be fixed and the displacement will be
    applied.

    Args:
        position: Position in voxels
        fixed_dof: Fixed degrees of freedom
        force: Force vector in N
        displacement: Displacement vector in mm
        torque: Torque values in Nm
        angular_displacement: Angular displacement values in deg
        name: Boundary condition name
    
    Returns:
        None
    &#34;&#34;&#34;
    x = position[0] - self.__model.coords[0]
    y = position[1] - self.__model.coords[1]
    z = position[2] - self.__model.coords[2]

    x_len = int(self.__model.voxels.shape[0])
    y_len = int(self.__model.voxels.shape[1])
    z_len = int(self.__model.voxels.shape[2])

    pos = ((x+0.5)/x_len, (y+0.5)/y_len, (z+0.5)/z_len)
    radius = 0.49/x_len

    bc = _BCRegion(name, BCShape.SPHERE, pos, (0.0, 0.0, 0.0), radius, fixed_dof, force, displacement, torque, angular_displacement)
    self.__bcRegions.append(bc)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.addDisconnection"><code class="name flex">
<span>def <span class="ident">addDisconnection</span></span>(<span>self, voxel_1:Â Tuple[int,Â int,Â int], voxel_2:Â Tuple[int,Â int,Â int])</span>
</code></dt>
<dd>
<div class="desc"><p>Specify a pair of voxels which should be disconnected</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxel_1</code></strong></dt>
<dd>Coordinates in voxels</dd>
<dt><strong><code>voxel_2</code></strong></dt>
<dd>Coordinates in voxels</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addDisconnection(self, voxel_1: Tuple[int, int, int], voxel_2: Tuple[int, int, int]):
    &#34;&#34;&#34;
    Specify a pair of voxels which should be disconnected

    Args:
        voxel_1: Coordinates in voxels
        voxel_2: Coordinates in voxels
    
    Returns:
        None
    &#34;&#34;&#34;
    dc = _Disconnection(voxel_1, voxel_2)
    self.__disconnections.append(dc)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.addKeyframe"><code class="name flex">
<span>def <span class="ident">addKeyframe</span></span>(<span>self, time_value:Â floatÂ =Â 0, amplitude_pos:Â floatÂ =Â 0, amplitude_neg:Â floatÂ =Â -1, percent_pos:Â floatÂ =Â 0.5, period:Â floatÂ =Â 1.0, phase_offset:Â floatÂ =Â 0, temp_offset:Â floatÂ =Â 0, const_temp:Â boolÂ =Â False, square_wave:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a keyframe to a temperature control group.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>time_value</code></strong></dt>
<dd>Time at which keyframe should take effect (sec)</dd>
<dt><strong><code>amplitude_pos</code></strong></dt>
<dd>Control element positive temperature amplitude (deg C)</dd>
<dt><strong><code>amplitude_neg</code></strong></dt>
<dd>Control element negative temperature amplitude (deg C)</dd>
<dt><strong><code>percent_pos</code></strong></dt>
<dd>Percent of period spanned by positive temperature amplitude (0-1)</dd>
<dt><strong><code>period</code></strong></dt>
<dd>Period of the control signal (sec)</dd>
<dt><strong><code>phase_offset</code></strong></dt>
<dd>Control element phase offset for time-varying thermal (rad)</dd>
<dt><strong><code>temp_offset</code></strong></dt>
<dd>Control element temperature offset for time-varying thermal (deg C)</dd>
<dt><strong><code>const_temp</code></strong></dt>
<dd>Enable/disable setting a constant target temperature that respects heating/cooling rates</dd>
<dt><strong><code>square_wave</code></strong></dt>
<dd>Enable/disable converting signal to a square wave (positive -&gt; a = amplitude1, negative -&gt; a = 0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addKeyframe(self, time_value: float = 0, amplitude_pos: float = 0, amplitude_neg: float = -1, percent_pos: float = 0.5,
                period: float = 1.0, phase_offset: float = 0, temp_offset: float = 0, const_temp: bool = False, square_wave: bool = False):
    &#34;&#34;&#34;
    Add a keyframe to a temperature control group.

    Args:
        time_value: Time at which keyframe should take effect (sec)
        amplitude_pos: Control element positive temperature amplitude (deg C)
        amplitude_neg: Control element negative temperature amplitude (deg C)
        percent_pos: Percent of period spanned by positive temperature amplitude (0-1)
        period: Period of the control signal (sec)
        phase_offset: Control element phase offset for time-varying thermal (rad)
        temp_offset: Control element temperature offset for time-varying thermal (deg C)
        const_temp: Enable/disable setting a constant target temperature that respects heating/cooling rates
        square_wave: Enable/disable converting signal to a square wave (positive -&gt; a = amplitude1, negative -&gt; a = 0)
    
    Returns:
        None
    &#34;&#34;&#34;
    amplitude_pos = max(amplitude_pos, 0) # amplitude_pos must be positive

    if amplitude_neg &lt; 0: # If amplitude neg is not given (or not negative) use amplitude_pos instead
        amplitude_neg = amplitude_pos

    g = self.__currentTempControlGroup
    kf = _Keyframe(time_value, amplitude_pos, amplitude_neg, percent_pos, period, phase_offset, temp_offset, const_temp, square_wave)
    self.__localTempControls[g].keyframes.append(kf)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.addSensor"><code class="name flex">
<span>def <span class="ident">addSensor</span></span>(<span>self, location:Â Tuple[int,Â int,Â int]Â =Â (0, 0, 0), axis:Â <a title="voxelfuse.simulation.Axis" href="#voxelfuse.simulation.Axis">Axis</a>Â =Â Axis.NONE, name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a sensor to a voxel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>Sensor location in voxels</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>Sensor measurement axis</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Sensor name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addSensor(self, location: Tuple[int, int, int] = (0, 0, 0), axis: Axis = Axis.NONE, name: str = None): # TODO: Make Voxelyze use axis parameter
    &#34;&#34;&#34;
    Add a sensor to a voxel.

    Args:
        location: Sensor location in voxels
        axis: Sensor measurement axis
        name: Sensor name
    
    Returns:
        None
    &#34;&#34;&#34;
    x = location[0] - self.__model.coords[0]
    y = location[1] - self.__model.coords[1]
    z = location[2] - self.__model.coords[2]

    sensor = _Sensor(name, (x, y, z), axis)
    self.__sensors.append(sensor)

    if not self.__model.isOccupied((x, y, z)):
        print(&#39;WARNING: No material present at sensor voxel &#39; + str((x, y, z)))</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.addTempControlGroup"><code class="name flex">
<span>def <span class="ident">addTempControlGroup</span></span>(<span>self, locations:Â List[Tuple[int,Â int,Â int]]Â =Â None, name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new temperature control group and select it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>locations</code></strong></dt>
<dd>Control element locations in voxels as a list of tuples</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Group name</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addTempControlGroup(self, locations: List[Tuple[int, int, int]] = None, name: str = None):
    &#34;&#34;&#34;
    Add a new temperature control group and select it.

    Args:
        locations: Control element locations in voxels as a list of tuples
        name: Group name
    
    Returns:
        None
    &#34;&#34;&#34;
    # Enable temperature control
    self.__temperatureEnable = True
    self.__temperatureVaryEnable = True

    if locations is None:
        print(&#39;No locations provided - applying temperature control group to entire model&#39;)

        x_len = self.__model.voxels.shape[0]
        y_len = self.__model.voxels.shape[1]
        z_len = self.__model.voxels.shape[2]

        locations = []
        for x in range(x_len):
            for y in range(y_len):
                for z in range(z_len):
                    locations.append((x, y, z))

    group = _TempControlGroup(name, locations, [])
    self.__localTempControls.append(group)
    self.__currentTempControlGroup = len(self.__localTempControls)-1</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.applyTempMap"><code class="name flex">
<span>def <span class="ident">applyTempMap</span></span>(<span>self, time_value, amp_pos_map, amp_neg_map=None, percent_pos_map=None, period_map=None, phase_map=None, offset_map=None, const_temp_map=None, square_wave_map=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the simulation temperature control elements based on a value maps of target temperature settings.</p>
<p>This function relies on the temperature control groups being in a specific order. initializeTempMap should be called prior to running this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>time_value</code></strong></dt>
<dd>Time at which keyframe should take effect (sec)</dd>
<dt><strong><code>amp_pos_map</code></strong></dt>
<dd>Array of target positive temperature amplitudes for each voxel (deg C)</dd>
<dt><strong><code>amp_neg_map</code></strong></dt>
<dd>Array of target negative temperature amplitudes for each voxel (deg C)</dd>
<dt><strong><code>percent_pos_map</code></strong></dt>
<dd>Array containing percent of period spanned by positive temperature amplitude for each voxel</dd>
<dt><strong><code>period_map</code></strong></dt>
<dd>Array of signal periods for each voxel (sec)</dd>
<dt><strong><code>phase_map</code></strong></dt>
<dd>Array of phase offsets for each voxel (rad)</dd>
<dt><strong><code>offset_map</code></strong></dt>
<dd>Array of temperature offsets for each voxel (deg C)</dd>
<dt><strong><code>const_temp_map</code></strong></dt>
<dd>Array of boolean values to enable/disable constant temperature mode</dd>
<dt><strong><code>square_wave_map</code></strong></dt>
<dd>Array of boolean values to enable/disable square wave mode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def applyTempMap(self, time_value, amp_pos_map, amp_neg_map=None, percent_pos_map=None, period_map=None,
                 phase_map=None, offset_map=None, const_temp_map=None, square_wave_map=None):
    &#34;&#34;&#34;
    Set the simulation temperature control elements based on a value maps of target temperature settings.

    This function relies on the temperature control groups being in a specific order. initializeTempMap should be called prior to running this function.

    Args:
        time_value: Time at which keyframe should take effect (sec)
        amp_pos_map: Array of target positive temperature amplitudes for each voxel (deg C)
        amp_neg_map: Array of target negative temperature amplitudes for each voxel (deg C)
        percent_pos_map: Array containing percent of period spanned by positive temperature amplitude for each voxel
        period_map: Array of signal periods for each voxel (sec)
        phase_map: Array of phase offsets for each voxel (rad)
        offset_map: Array of temperature offsets for each voxel (deg C)
        const_temp_map: Array of boolean values to enable/disable constant temperature mode
        square_wave_map: Array of boolean values to enable/disable square wave mode
    
    Returns:
        None
    &#34;&#34;&#34;
    # Get map size
    x_len = amp_pos_map.shape[0]
    y_len = amp_pos_map.shape[1]
    z_len = amp_pos_map.shape[2]

    # Generate the control element for each voxel
    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                if abs(amp_pos_map[x, y, z]) &gt; FLOATING_ERROR or ((amp_neg_map is not None) and (abs(amp_neg_map[x, y, z]) &gt; FLOATING_ERROR)):  # If voxel is not empty
                    amplitude_pos = amp_pos_map[x, y, z]

                    if amp_neg_map is None:
                        amplitude_neg = amp_pos_map[x, y, z]
                    else:
                        amplitude_neg = amp_neg_map[x, y, z]

                    if percent_pos_map is None:
                        percent_pos = 0.5
                    else:
                        percent_pos = percent_pos_map[x, y, z]

                    if period_map is None:
                        period = 1.0
                    else:
                        period = period_map[x, y, z]

                    if phase_map is None:
                        phase_offset = 0
                    else:
                        phase_offset = phase_map[x, y, z]

                    if offset_map is None:
                        temp_offset = 0
                    else:
                        temp_offset = offset_map[x, y, z]

                    if const_temp_map is None:
                        const_temp = False
                    else:
                        const_temp = const_temp_map[x, y, z]

                    if square_wave_map is None:
                        square_wave = False
                    else:
                        square_wave = square_wave_map[x, y, z]

                    kf = _Keyframe(time_value, amplitude_pos, amplitude_neg, percent_pos, period, phase_offset, temp_offset, const_temp, square_wave)
                    g = z + y*z_len + x*y_len*z_len
                    self.__localTempControls[g].keyframes.append(kf)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.cleanTempControlGroups"><code class="name flex">
<span>def <span class="ident">cleanTempControlGroups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove invalid temperature control groups.</p>
<p>Invalid groups have no keyframes, or have no target voxels.</p>
<h2 id="returns">Returns</h2>
<p>Number of groups removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanTempControlGroups(self):
    &#34;&#34;&#34;
    Remove invalid temperature control groups.

    Invalid groups have no keyframes, or have no target voxels.
    
    Returns:
        Number of groups removed
    &#34;&#34;&#34;
    removed_groups = []
    for g in range(len(self.__localTempControls)):
        g = g - len(removed_groups)
        group = self.__localTempControls[g]
        if len(group.keyframes) == 0 or len(group.locations) == 0:
            removed_groups.append(self.removeTempControlGroup(g))

    self.__currentTempControlGroup = len(self.__localTempControls)-1

    named_groups = []
    for n in removed_groups:
        if n is not None:
            named_groups.append(n)

    if len(removed_groups) == 0:
        pass
    elif len(named_groups) == 0:
        print(&#39;Removed &#39; + str(len(removed_groups)) + &#39; temperature control groups&#39;)
    else:
        print(&#39;Removed &#39; + str(len(removed_groups)) + &#39; temperature control groups, including: &#39; + str(named_groups))

    return len(removed_groups)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.clearBoundaryConditions"><code class="name flex">
<span>def <span class="ident">clearBoundaryConditions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all boundary conditions from a Simulation object.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearBoundaryConditions(self):
    &#34;&#34;&#34;
    Remove all boundary conditions from a Simulation object.
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__bcRegions = []
    # self.__bcVoxels = []</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.clearDisconnections"><code class="name flex">
<span>def <span class="ident">clearDisconnections</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all disconnected voxel bonds.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearDisconnections(self):
    &#34;&#34;&#34;
    Clear all disconnected voxel bonds.
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__disconnections = []</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.clearKeyframes"><code class="name flex">
<span>def <span class="ident">clearKeyframes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all keyframes assigned to the current temperature control group.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearKeyframes(self):
    &#34;&#34;&#34;
    Remove all keyframes assigned to the current temperature control group.
    
    Returns:
        None
    &#34;&#34;&#34;
    g = self.__currentTempControlGroup
    self.__localTempControls[g].keyframes = []</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.clearSensors"><code class="name flex">
<span>def <span class="ident">clearSensors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all sensors from a Simulation object.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearSensors(self):
    &#34;&#34;&#34;
    Remove all sensors from a Simulation object.
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__sensors = []</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.clearTempControlGroups"><code class="name flex">
<span>def <span class="ident">clearTempControlGroups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all temperature control groups.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearTempControlGroups(self):
    &#34;&#34;&#34;
    Clear all temperature control groups.
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__currentTempControlGroup = 0
    self.__localTempControls = []</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getCollision"><code class="name flex">
<span>def <span class="ident">getCollision</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get simulation collision parameters.</p>
<h2 id="returns">Returns</h2>
<p>Enable/disable collisions, Collision damping</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCollision(self):
    &#34;&#34;&#34;
    Get simulation collision parameters.
    
    Returns:
        Enable/disable collisions, Collision damping
    &#34;&#34;&#34;
    return self.__collisionEnable, self.__collisionDamping</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getDamping"><code class="name flex">
<span>def <span class="ident">getDamping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get simulation damping parameters.</p>
<h2 id="returns">Returns</h2>
<p>Voxel bond damping, Environment damping</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDamping(self):
    &#34;&#34;&#34;
    Get simulation damping parameters.
    
    Returns:
        Voxel bond damping, Environment damping
    &#34;&#34;&#34;
    return self.__dampingBond, self.__dampingEnvironment</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getEquilibriumMode"><code class="name flex">
<span>def <span class="ident">getEquilibriumMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get simulation equilibrium mode.</p>
<h2 id="returns">Returns</h2>
<p>Enable/disable equilibrium mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEquilibriumMode(self):
    &#34;&#34;&#34;
    Get simulation equilibrium mode.
    
    Returns:
        Enable/disable equilibrium mode
    &#34;&#34;&#34;
    return self.__equilibriumModeEnable</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getGravity"><code class="name flex">
<span>def <span class="ident">getGravity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get simulation gravity parameters.</p>
<h2 id="returns">Returns</h2>
<p>Enable/disable gravity, Acceleration due to gravity in m/sec^2, Enable/disable ground plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGravity(self):
    &#34;&#34;&#34;
    Get simulation gravity parameters.
    
    Returns:
        Enable/disable gravity, Acceleration due to gravity in m/sec^2, Enable/disable ground plane
    &#34;&#34;&#34;
    return self.__gravityEnable, self.__gravityValue, self.__floorEnable</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getHydrogelModel"><code class="name flex">
<span>def <span class="ident">getHydrogelModel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get hydrogel model parameters.</p>
<h2 id="returns">Returns</h2>
<p>Enable/disable hydrogel model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHydrogelModel(self):
    &#34;&#34;&#34;
    Get hydrogel model parameters.
    
    Returns:
        Enable/disable hydrogel model
    &#34;&#34;&#34;
    return self.__hydrogelModelEnable</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getModel"><code class="name flex">
<span>def <span class="ident">getModel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the simulation model.</p>
<h2 id="returns">Returns</h2>
<p>VoxelModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getModel(self):
    &#34;&#34;&#34;
    Get the simulation model.
    
    Returns:
        VoxelModel
    &#34;&#34;&#34;
    return self.__model</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getStopCondition"><code class="name flex">
<span>def <span class="ident">getStopCondition</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get simulation stop condition.</p>
<h2 id="returns">Returns</h2>
<p>Stop condition type, Stop condition value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getStopCondition(self):
    &#34;&#34;&#34;
    Get simulation stop condition.
    
    Returns:
        Stop condition type, Stop condition value
    &#34;&#34;&#34;
    return self.__stopConditionType, self.__stopConditionValue</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getThermal"><code class="name flex">
<span>def <span class="ident">getThermal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get simulation temperature parameters.</p>
<h2 id="returns">Returns</h2>
<p>Enable/disable temperature, Base temperature in degrees C, Enable/disable temperature fluctuation, Temperature fluctuation amplitude, Temperature fluctuation period, Temperature offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getThermal(self):
    &#34;&#34;&#34;
    Get simulation temperature parameters.
    
    Returns:
        Enable/disable temperature, Base temperature in degrees C, Enable/disable temperature fluctuation, Temperature fluctuation amplitude, Temperature fluctuation period, Temperature offset
    &#34;&#34;&#34;
    return self.__temperatureEnable, self.__temperatureBaseValue, self.__temperatureVaryEnable, self.__temperatureVaryAmplitude, self.__temperatureVaryPeriod, self.__temperatureVaryOffset</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.getVoxelDim"><code class="name flex">
<span>def <span class="ident">getVoxelDim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the side dimension of a voxel in mm.</p>
<h2 id="returns">Returns</h2>
<p>Float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVoxelDim(self):
    &#34;&#34;&#34;
    Get the side dimension of a voxel in mm.
    
    Returns:
        Float
    &#34;&#34;&#34;
    res = self.__model.resolution
    return (1.0/res) * 0.001</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.initializeTempMap"><code class="name flex">
<span>def <span class="ident">initializeTempMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize temperature control groups to which keyframes will be stored when using applyTempMap.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initializeTempMap(self):
    &#34;&#34;&#34;
    Initialize temperature control groups to which keyframes will be stored when using applyTempMap.
    
    Returns:
        None
    &#34;&#34;&#34;
    # Clear any existing temperature controls
    self.clearTempControlGroups()

    # Get map size
    x_len = self.__model.voxels.shape[0]
    y_len = self.__model.voxels.shape[1]
    z_len = self.__model.voxels.shape[2]

    # Generate empty control element for each voxel
    for x in range(x_len):
        for y in range(y_len):
            for z in range(z_len):
                self.addTempControlGroup([(x, y, z)])</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.removeTempControlGroup"><code class="name flex">
<span>def <span class="ident">removeTempControlGroup</span></span>(<span>self, index:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a temperature control group by index.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>Temperature control group index</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Name of removed group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeTempControlGroup(self, index: int = 0):
    &#34;&#34;&#34;
    Remove a temperature control group by index.

    Args:
        index: Temperature control group index
    
    Returns:
        Name of removed group
    &#34;&#34;&#34;
    group = self.__localTempControls.pop(index)
    self.__currentTempControlGroup = len(self.__localTempControls)-1
    return group.name</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.runSim"><code class="name flex">
<span>def <span class="ident">runSim</span></span>(<span>self, filename:Â strÂ =Â 'temp', value_map:Â intÂ =Â 0, delete_files:Â boolÂ =Â True, log_interval:Â intÂ =Â -1, history_interval:Â intÂ =Â -1, voxelyze_on_path:Â boolÂ =Â False, wsl:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a Simulation object using Voxelyze.</p>
<p>This function will create a .vxa file, run the file with Voxelyze, and then load the .xml results file into
the results attribute of the Simulation object. Enabling delete_files will delete both the .vxa and .xml files
once the results have been loaded.</p>
<p>History files can be viewed using <a href="https://github.com/voxcraft/voxcraft-viz">https://github.com/voxcraft/voxcraft-viz</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name for .vxa and .xml files</dd>
<dt><strong><code>value_map</code></strong></dt>
<dd>Index of the desired value map type</dd>
<dt><strong><code>log_interval</code></strong></dt>
<dd>Set the step interval at which sensor log entries should be recorded, -1 to disable log</dd>
<dt><strong><code>history_interval</code></strong></dt>
<dd>Set the step interval at which history file entries should be recorded, -1 for default interval</dd>
<dt><strong><code>delete_files</code></strong></dt>
<dd>Enable/disable deleting simulation file when process is complete</dd>
<dt><strong><code>voxelyze_on_path</code></strong></dt>
<dd>Enable/disable using system Voxelyze rather than bundled Voxelyze</dd>
<dt><strong><code>wsl</code></strong></dt>
<dd>Enable/disable using Windows Subsystem for Linux with bundled Voxelyze</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runSim(self, filename: str = &#39;temp&#39;, value_map: int = 0, delete_files: bool = True, log_interval: int = -1, history_interval: int = -1, voxelyze_on_path: bool = False, wsl: bool = False):
    &#34;&#34;&#34;
    Run a Simulation object using Voxelyze.

    This function will create a .vxa file, run the file with Voxelyze, and then load the .xml results file into
    the results attribute of the Simulation object. Enabling delete_files will delete both the .vxa and .xml files
    once the results have been loaded.

    History files can be viewed using https://github.com/voxcraft/voxcraft-viz

    Args:
        filename: File name for .vxa and .xml files
        value_map: Index of the desired value map type
        log_interval: Set the step interval at which sensor log entries should be recorded, -1 to disable log
        history_interval: Set the step interval at which history file entries should be recorded, -1 for default interval
        delete_files: Enable/disable deleting simulation file when process is complete
        voxelyze_on_path: Enable/disable using system Voxelyze rather than bundled Voxelyze
        wsl: Enable/disable using Windows Subsystem for Linux with bundled Voxelyze
    
    Returns:
        None
    &#34;&#34;&#34;
    # Generate results file/directory names
    filename = filename + &#39;_&#39; + str(self.id)
    dirname = &#39;sim_results_&#39; + str(self.date)

    # Create results directory
    if not os.path.exists(dirname):
        os.makedirs(dirname)

    # Create simulation file
    self.saveVXA(dirname + &#39;/&#39; + filename)

    if voxelyze_on_path:
        command_string = &#39;voxelyze&#39;
    else:
        # Check OS type
        if os.name.startswith(&#39;nt&#39;): # Windows
            if wsl:
                command_string = &#39;wsl &#34;&#39; + os.path.dirname(os.path.realpath(__file__)).replace(&#39;C:&#39;, &#39;/mnt/c&#39;).replace(&#39;\\&#39;, &#39;/&#39;) + &#39;/utils/voxelyze&#34;&#39;
            else:
                command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}\\utils\\voxelyze.exe&#34;&#39;
        else: # Linux
            command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}/utils/voxelyze&#34;&#39;

    command_string = command_string + &#39; -f &#39; + dirname + &#39;/&#39; + filename + &#39;.vxa -o &#39; + dirname + &#39;/&#39; + filename + &#39; -vm &#39; + str(value_map) + &#39; -p&#39;

    if log_interval &gt; 0:
        command_string = command_string + &#39; -log-interval &#39; + str(log_interval)

    if history_interval &gt; 0:
        command_string = command_string + &#39; -history-interval &#39; + str(history_interval)

    print(&#39;Launching Voxelyze using: &#39; + command_string)
    p = subprocess.Popen(command_string, shell=True)
    p.wait()

    # Open simulation results
    f = open(dirname + &#39;/&#39; + filename + &#39;.xml&#39;, &#39;r&#39;)
    #print(&#39;Opening file: &#39; + f.name)
    data = f.readlines()
    f.close()

    # Clear any previous results
    self.results = []

    # Find start and end locations for individual sensors
    startLoc = []
    endLoc = []
    for row in range(len(data)): # tqdm(range(len(data)), desc=&#39;Finding sensor tags&#39;):
        data[row] = data[row].replace(&#39;\t&#39;, &#39;&#39;)
        if data[row][:-1] == &#39;&lt;Sensor&gt;&#39;:
            startLoc.append(row)
        elif data[row][:-1] == &#39;&lt;/Sensor&gt;&#39;:
            endLoc.append(row)

    # Read the data from each sensor
    sensor_count = len(startLoc)
    if sensor_count &gt; 0:
        for sensor in range(sensor_count): # tqdm(range(len(startLoc)), desc=&#39;Reading sensor results&#39;):
            # Create a dictionary to hold the current sensor results
            sensorResults = {}

            # Read the data from each sensor tag
            for row in range(startLoc[sensor]+1, endLoc[sensor]):
                # Determine the current tag
                tag = &#39;&#39;
                for col in range(1, len(data[row])):
                    if data[row][col] == &#39;&gt;&#39;:
                        tag = data[row][1:col]
                        break

                # Remove the tags and newline to determine the current value
                data[row] = data[row].replace(&#39;&lt;&#39;+tag+&#39;&gt;&#39;, &#39;&#39;).replace(&#39;&lt;/&#39;+tag+&#39;&gt;&#39;, &#39;&#39;)
                value = data[row][:-1]

                # Combine the current tag and value
                if tag == &#39;Location&#39;:
                    coords =  tuple(map(int, value.split(&#39; &#39;)))
                    x = coords[0] + self.__model.coords[0]
                    y = coords[1] + self.__model.coords[1]
                    z = coords[2] + self.__model.coords[2]
                    currentResult = {tag:(x, y, z)}
                elif &#39; &#39; in value:
                    currentResult = {tag:tuple(map(float, value.split(&#39; &#39;)))}
                else:
                    currentResult = {tag:float(value)}

                # Add the current tag and value to the sensor results dictionary
                sensorResults.update(currentResult)

            # Append the results dictionary for the current sensor to the simulation results list
            self.results.append(sensorResults)
    else:
        print(&#39;No sensors found&#39;)

    if os.path.exists(&#39;value_map.txt&#39;):
        # Open simulation value map results
        f = open(&#39;value_map.txt&#39;, &#39;r&#39;)
        print(&#39;Opening file: &#39; + f.name)
        data = f.readlines()
        f.close()

        # Clear any previous results
        self.valueMap = np.zeros_like(self.__model.voxels, dtype=np.float32)

        # Get map size
        x_len = self.valueMap.shape[0]
        y_len = self.valueMap.shape[1]
        z_len = self.valueMap.shape[2]

        for z in range(z_len): # tqdm(range(z_len), desc=&#39;Loading layers&#39;):
            vals = np.array(data[z][:-2].split(&#34;,&#34;), dtype=np.float32)
            for y in range(y_len):
                self.valueMap[:, y, z] = vals[y*x_len:(y+1)*x_len]

    # Remove temporary files
    if delete_files:
        os.remove(dirname + &#39;/&#39; + filename + &#39;.vxa&#39;)
        os.remove(dirname + &#39;/&#39; + filename + &#39;.xml&#39;)

        if os.path.exists(dirname + &#39;/value_map.txt&#39;):
            os.remove(dirname + &#39;/value_map.txt&#39;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.runSimVoxCad"><code class="name flex">
<span>def <span class="ident">runSimVoxCad</span></span>(<span>self, filename:Â strÂ =Â 'temp', delete_files:Â boolÂ =Â True, voxcad_on_path:Â boolÂ =Â False, wsl:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a Simulation object using the VoxCad GUI.</p>
<hr>
<p>Example:</p>
<p><code>simulation = Simulation(modelResult)</code></p>
<p><code>simulation.setCollision()</code></p>
<p><code>simulation.setStopCondition(<a title="voxelfuse.simulation.StopCondition.TIME_VALUE" href="#voxelfuse.simulation.StopCondition.TIME_VALUE">StopCondition.TIME_VALUE</a>, 0.01)</code></p>
<p><code>simulation.runSimVoxCad('collision_sim_1', delete_files=False)</code></p>
<hr>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
<dt><strong><code>delete_files</code></strong></dt>
<dd>Enable/disable deleting simulation file when VoxCad is closed</dd>
<dt><strong><code>voxcad_on_path</code></strong></dt>
<dd>Enable/disable using system VoxCad rather than bundled VoxCad</dd>
<dt><strong><code>wsl</code></strong></dt>
<dd>Enable/disable using Windows Subsystem for Linux with bundled VoxCad</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runSimVoxCad(self, filename: str = &#39;temp&#39;, delete_files: bool = True, voxcad_on_path: bool = False, wsl: bool = False):
    &#34;&#34;&#34;
    Run a Simulation object using the VoxCad GUI.

    ----

    Example:

    ``simulation = Simulation(modelResult)``

    ``simulation.setCollision()``

    ``simulation.setStopCondition(StopCondition.TIME_VALUE, 0.01)``

    ``simulation.runSimVoxCad(&#39;collision_sim_1&#39;, delete_files=False)``

    ----

    Args:
        filename: File name
        delete_files: Enable/disable deleting simulation file when VoxCad is closed
        voxcad_on_path: Enable/disable using system VoxCad rather than bundled VoxCad
        wsl: Enable/disable using Windows Subsystem for Linux with bundled VoxCad
    
    Returns:
        None
    &#34;&#34;&#34;
    # Generate file name
    filename = filename + &#39;_&#39; + str(self.id)

    # Create simulation file
    self.saveVXA(filename)

    if voxcad_on_path:
        command_string = &#39;voxcad &#39;
    else:
        # Check OS type
        if os.name.startswith(&#39;nt&#39;): # Windows
            if wsl:
                command_string = &#39;wsl &#34;&#39; + os.path.dirname(os.path.realpath(__file__)).replace(&#39;C:&#39;, &#39;/mnt/c&#39;).replace(&#39;\\&#39;, &#39;/&#39;) + &#39;/utils/VoxCad&#34; &#39;
            else:
                command_string = f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}\\utils\\VoxCad.exe&#34; &#39;
        else: # Linux
            command_string =  f&#39;&#34;{os.path.dirname(os.path.realpath(__file__))}/utils/VoxCad&#34; &#39;

    command_string = command_string + filename + &#39;.vxa&#39;

    print(&#39;Launching VoxCad using: &#39; + command_string)
    p = subprocess.Popen(command_string, shell=True)
    p.wait()

    if delete_files:
        print(&#39;Removing file: &#39; + filename + &#39;.vxa&#39;)
        os.remove(filename + &#39;.vxa&#39;)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.saveResults"><code class="name flex">
<span>def <span class="ident">saveResults</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a simulation's results dictionary to a .csv file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>Name of output file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveResults(self, filename):
    &#34;&#34;&#34;
    Saves a simulation&#39;s results dictionary to a .csv file.

    Args:
        filename: Name of output file

    Returns:
        None
    &#34;&#34;&#34;
    # Get result table keys and size
    keys = list(self.results[0].keys())
    rows = len(self.results)
    cols = len(keys)

    # Create results file
    f = open(filename + &#39;.csv&#39;, &#39;w+&#39;)
    print(&#39;Saving file: &#39; + f.name)

    # Write headings
    f.write(&#39;Sensor&#39;)
    for c in range(cols):
        f.write(&#39;,&#39; + str(keys[c]))
    f.write(&#39;\n&#39;)

    # Write values
    for r in range(rows):
        f.write(str(r))
        vals = list(self.results[r].values())
        for c in range(cols):
            f.write(&#39;,&#39; + str(vals[c]).replace(&#39;,&#39;, &#39; &#39;))
        f.write(&#39;\n&#39;)

    # Close file
    f.close()</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.saveVXA"><code class="name flex">
<span>def <span class="ident">saveVXA</span></span>(<span>self, filename:Â str, compression:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Save model data to a .vxa file</p>
<p>The VoxCad simulation file format stores all the data contained in
a .vxc file (geometry, material palette) plus the simulation setup (simulation
parameters, environment settings, boundary conditions).</p>
<p>This format supports compression for the voxel data. Enabling compression allows
for larger models, but it may introduce geometry errors that particularly affect
small models.</p>
<p>The .vxa file type can be opened using VoxCad simulation software. However, it
cannot currently be reopened by a VoxelFuse script.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>File name</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>Enable/disable voxel data compression</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveVXA(self, filename: str, compression: bool = False):
    &#34;&#34;&#34;
    Save model data to a .vxa file

    The VoxCad simulation file format stores all the data contained in
    a .vxc file (geometry, material palette) plus the simulation setup (simulation
    parameters, environment settings, boundary conditions).

    This format supports compression for the voxel data. Enabling compression allows
    for larger models, but it may introduce geometry errors that particularly affect
    small models.

    The .vxa file type can be opened using VoxCad simulation software. However, it
    cannot currently be reopened by a VoxelFuse script.

    Args:
        filename: File name
        compression: Enable/disable voxel data compression
    
    Returns:
        None
    &#34;&#34;&#34;
    self.cleanTempControlGroups()
    f = open(filename + &#39;.vxa&#39;, &#39;w+&#39;)
    print(&#39;Saving file: &#39; + f.name)

    writeHeader(f, &#39;1.0&#39;, &#39;ISO-8859-1&#39;)
    writeOpen(f, &#39;VXA Version=&#34;&#39; + str(1.1) + &#39;&#34;&#39;, 0)
    self.writeSimData(f)
    self.writeEnvironmentData(f)
    self.writeSensors(f)
    self.writeTempControls(f)
    self.writeDisconnections(f)
    self.__model.writeVXCData(f, compression)
    writeClos(f, &#39;VXA&#39;, 0)
    f.close()</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.selectTempControlGroup"><code class="name flex">
<span>def <span class="ident">selectTempControlGroup</span></span>(<span>self, index:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Select which keyframe new temperature control elements should be added to.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>Temperature control group index</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectTempControlGroup(self, index: int = 0):
    &#34;&#34;&#34;
    Select which keyframe new temperature control elements should be added to.

    Args:
        index: Temperature control group index
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__currentTempControlGroup = index</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setCollision"><code class="name flex">
<span>def <span class="ident">setCollision</span></span>(<span>self, enable:Â boolÂ =Â True, damping:Â floatÂ =Â 1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set simulation collision parameters.</p>
<p>A damping value of 0 represents completely elastic collisions and
higher values represent inelastic collisions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable</code></strong></dt>
<dd>Enable/disable collisions</dd>
<dt><strong><code>damping</code></strong></dt>
<dd>Collision damping (0-2)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCollision(self, enable: bool = True, damping: float = 1.0):
    &#34;&#34;&#34;
    Set simulation collision parameters.

    A damping value of 0 represents completely elastic collisions and
    higher values represent inelastic collisions.

    Args:
        enable: Enable/disable collisions
        damping: Collision damping (0-2)
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__collisionEnable = enable
    self.__collisionDamping = damping</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setDamping"><code class="name flex">
<span>def <span class="ident">setDamping</span></span>(<span>self, bond:Â floatÂ =Â 1.0, environment:Â floatÂ =Â 0.0001)</span>
</code></dt>
<dd>
<div class="desc"><p>Set simulation damping parameters.</p>
<p>Environment damping can be used to simulate fluid environments. 0 represents
a vacuum and larger values represent a viscous fluid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bond</code></strong></dt>
<dd>Voxel bond damping (0-1)</dd>
<dt><strong><code>environment</code></strong></dt>
<dd>Environment damping (0-0.1)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDamping(self, bond: float = 1.0, environment: float = 0.0001):
    &#34;&#34;&#34;
    Set simulation damping parameters.

    Environment damping can be used to simulate fluid environments. 0 represents
    a vacuum and larger values represent a viscous fluid.

    Args:
        bond: Voxel bond damping (0-1)
        environment: Environment damping (0-0.1)
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__dampingBond = bond
    self.__dampingEnvironment = environment</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setEquilibriumMode"><code class="name flex">
<span>def <span class="ident">setEquilibriumMode</span></span>(<span>self, enable:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set simulation equilibrium mode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable</code></strong></dt>
<dd>Enable/disable equilibrium mode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setEquilibriumMode(self, enable: bool = True):
    &#34;&#34;&#34;
    Set simulation equilibrium mode.

    Args:
        enable: Enable/disable equilibrium mode
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__equilibriumModeEnable = enable</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setFixedThermal"><code class="name flex">
<span>def <span class="ident">setFixedThermal</span></span>(<span>self, enable:Â boolÂ =Â True, base_temp:Â floatÂ =Â 25.0, growth_amplitude:Â floatÂ =Â 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a fixed environment temperature.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable</code></strong></dt>
<dd>Enable/disable temperature</dd>
<dt><strong><code>base_temp</code></strong></dt>
<dd>Temperature in degrees C</dd>
<dt><strong><code>growth_amplitude</code></strong></dt>
<dd>Set to 1 to enable expansion from base size</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setFixedThermal(self, enable: bool = True, base_temp: float = 25.0, growth_amplitude: float = 0.0):
    &#34;&#34;&#34;
    Set a fixed environment temperature.

    Args:
        enable: Enable/disable temperature
        base_temp: Temperature in degrees C
        growth_amplitude: Set to 1 to enable expansion from base size
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__temperatureEnable = enable
    self.__temperatureBaseValue = base_temp
    self.__temperatureVaryEnable = False
    self.__growthAmplitude = growth_amplitude</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setGravity"><code class="name flex">
<span>def <span class="ident">setGravity</span></span>(<span>self, enable:Â boolÂ =Â True, value:Â floatÂ =Â -9.81, enable_floor:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set simulation gravity parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable</code></strong></dt>
<dd>Enable/disable gravity</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Acceleration due to gravity in m/sec^2</dd>
<dt><strong><code>enable_floor</code></strong></dt>
<dd>Enable/disable ground plane</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setGravity(self, enable: bool = True, value: float = -9.81, enable_floor: bool = True):
    &#34;&#34;&#34;
    Set simulation gravity parameters.

    Args:
        enable: Enable/disable gravity
        value: Acceleration due to gravity in m/sec^2
        enable_floor: Enable/disable ground plane
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__gravityEnable = enable
    self.__gravityValue = value
    self.__floorEnable = enable_floor</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setHydrogelModel"><code class="name flex">
<span>def <span class="ident">setHydrogelModel</span></span>(<span>self, enable:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set hydrogel model parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable</code></strong></dt>
<dd>Enable/disable hydrogel model</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setHydrogelModel(self, enable: bool = True):
    &#34;&#34;&#34;
    Set hydrogel model parameters.

    Args:
        enable: Enable/disable hydrogel model
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__hydrogelModelEnable = enable</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setModel"><code class="name flex">
<span>def <span class="ident">setModel</span></span>(<span>self, voxel_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the model for a simulation.</p>
<p>Models located at positive coordinate values will have their workspace
size adjusted to maintain their position in the exported simulation.
Models located at negative coordinate values will be shifted to the origin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>voxel_model</code></strong></dt>
<dd>VoxelModel</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setModel(self, voxel_model):
    &#34;&#34;&#34;
    Set the model for a simulation.

    Models located at positive coordinate values will have their workspace
    size adjusted to maintain their position in the exported simulation.
    Models located at negative coordinate values will be shifted to the origin.

    Args:
        voxel_model: VoxelModel
    
    Returns:
        None
    &#34;&#34;&#34;
    # Fit workspace and union with an empty object at the origin to clear offsets if object is raised
    self.__model = ((VoxelModel.copy(voxel_model).fitWorkspace()) | empty(num_materials=(voxel_model.materials.shape[1] - 1))).removeDuplicateMaterials()</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setStopCondition"><code class="name flex">
<span>def <span class="ident">setStopCondition</span></span>(<span>self, condition:Â <a title="voxelfuse.simulation.StopCondition" href="#voxelfuse.simulation.StopCondition">StopCondition</a>Â =Â StopCondition.NONE, value:Â floatÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set simulation stop condition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong></dt>
<dd>Stop condition type, set using StopCondition class</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Stop condition value</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setStopCondition(self, condition: StopCondition = StopCondition.NONE, value: float = 0):
    &#34;&#34;&#34;
    Set simulation stop condition.

    Args:
        condition: Stop condition type, set using StopCondition class
        value: Stop condition value
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__stopConditionType = condition
    self.__stopConditionValue = value</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.setVaryingThermal"><code class="name flex">
<span>def <span class="ident">setVaryingThermal</span></span>(<span>self, enable:Â boolÂ =Â True, base_temp:Â floatÂ =Â 25.0, amplitude:Â floatÂ =Â 0.0, period:Â floatÂ =Â 1.0, offset:Â floatÂ =Â 0.0, growth_amplitude:Â floatÂ =Â 1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a varying environment temperature.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable</code></strong></dt>
<dd>Enable/disable temperature</dd>
<dt><strong><code>base_temp</code></strong></dt>
<dd>Base temperature in degrees C</dd>
<dt><strong><code>amplitude</code></strong></dt>
<dd>Temperature fluctuation amplitude</dd>
<dt><strong><code>period</code></strong></dt>
<dd>Temperature fluctuation period</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>Temperature offset (not currently supported)</dd>
<dt><strong><code>growth_amplitude</code></strong></dt>
<dd>Set to 1 to enable expansion from base size</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setVaryingThermal(self, enable: bool = True, base_temp: float = 25.0, amplitude: float = 0.0, period: float = 1.0, offset: float = 0.0, growth_amplitude: float = 1.0):
    &#34;&#34;&#34;
    Set a varying environment temperature.


    Args:
        enable: Enable/disable temperature
        base_temp: Base temperature in degrees C
        amplitude: Temperature fluctuation amplitude
        period: Temperature fluctuation period
        offset: Temperature offset (not currently supported)
        growth_amplitude: Set to 1 to enable expansion from base size
    
    Returns:
        None
    &#34;&#34;&#34;
    self.__temperatureEnable = enable
    self.__temperatureBaseValue = base_temp
    self.__temperatureVaryEnable = enable
    self.__temperatureVaryAmplitude = amplitude
    self.__temperatureVaryPeriod = period
    self.__temperatureVaryOffset = offset
    self.__growthAmplitude = growth_amplitude</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.writeDisconnections"><code class="name flex">
<span>def <span class="ident">writeDisconnections</span></span>(<span>self, f:Â <classÂ 'TextIO'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Write bond disconnections to a text file using the .vxa format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File to write to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeDisconnections(self, f: TextIO):
    &#34;&#34;&#34;
    Write bond disconnections to a text file using the .vxa format.

    Args:
        f: File to write to
    
    Returns:
        None
    &#34;&#34;&#34;
    writeOpen(f, &#39;Disconnections&#39;, 0)
    for dc in self.__disconnections:
        writeOpen(f, &#39;Break&#39;, 1)
        writeData(f, &#39;Voxel1&#39;, str(dc.vx1).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
        writeData(f, &#39;Voxel2&#39;, str(dc.vx2).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
        writeClos(f, &#39;Break&#39;, 1)
    writeClos(f, &#39;Disconnections&#39;, 0)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.writeEnvironmentData"><code class="name flex">
<span>def <span class="ident">writeEnvironmentData</span></span>(<span>self, f:Â <classÂ 'TextIO'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Write simulation environment parameters to a text file using the .vxa format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File to write to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeEnvironmentData(self, f: TextIO):
    &#34;&#34;&#34;
    Write simulation environment parameters to a text file using the .vxa format.

    Args:
        f: File to write to
    
    Returns:
        None
    &#34;&#34;&#34;
    # Environment settings
    writeOpen(f, &#39;Environment&#39;, 0)
    writeOpen(f, &#39;Boundary_Conditions&#39;, 1)
    writeData(f, &#39;NumBCs&#39;, len(self.__bcRegions), 2)
    for bc in self.__bcRegions:
        writeOpen(f, &#39;FRegion&#39;, 2)
        if bc.name is not None:
            writeData(f, &#39;Name&#39;, bc.name, 3)
        writeData(f, &#39;PrimType&#39;, int(bc.shape.value), 3)
        writeData(f, &#39;X&#39;, bc.position[0], 3)
        writeData(f, &#39;Y&#39;, bc.position[1], 3)
        writeData(f, &#39;Z&#39;, bc.position[2], 3)
        writeData(f, &#39;dX&#39;, bc.size[0], 3)
        writeData(f, &#39;dY&#39;, bc.size[1], 3)
        writeData(f, &#39;dZ&#39;, bc.size[2], 3)
        writeData(f, &#39;Radius&#39;, bc.radius, 3)
        writeData(f, &#39;R&#39;, bc.color[0], 3)
        writeData(f, &#39;G&#39;, bc.color[1], 3)
        writeData(f, &#39;B&#39;, bc.color[2], 3)
        writeData(f, &#39;alpha&#39;, bc.color[3], 3)
        writeData(f, &#39;DofFixed&#39;, bc.fixed_dof, 3)
        writeData(f, &#39;ForceX&#39;, bc.force[0], 3)
        writeData(f, &#39;ForceY&#39;, bc.force[1], 3)
        writeData(f, &#39;ForceZ&#39;, bc.force[2], 3)
        writeData(f, &#39;TorqueX&#39;, bc.torque[0], 3)
        writeData(f, &#39;TorqueY&#39;, bc.torque[1], 3)
        writeData(f, &#39;TorqueZ&#39;, bc.torque[2], 3)
        writeData(f, &#39;DisplaceX&#39;, bc.displacement[0] * 1e-3, 3)
        writeData(f, &#39;DisplaceY&#39;, bc.displacement[1] * 1e-3, 3)
        writeData(f, &#39;DisplaceZ&#39;, bc.displacement[2] * 1e-3, 3)
        writeData(f, &#39;AngDisplaceX&#39;, bc.angular_displacement[0], 3)
        writeData(f, &#39;AngDisplaceY&#39;, bc.angular_displacement[1], 3)
        writeData(f, &#39;AngDisplaceZ&#39;, bc.angular_displacement[2], 3)
        writeClos(f, &#39;FRegion&#39;, 2)
    writeClos(f, &#39;Boundary_Conditions&#39;, 1)

    writeOpen(f, &#39;Gravity&#39;, 1)
    writeData(f, &#39;GravEnabled&#39;, int(self.__gravityEnable), 2)
    writeData(f, &#39;GravAcc&#39;, self.__gravityValue, 2)
    writeData(f, &#39;FloorEnabled&#39;, int(self.__floorEnable), 2)
    writeClos(f, &#39;Gravity&#39;, 1)

    writeOpen(f, &#39;Thermal&#39;, 1)
    writeData(f, &#39;TempEnabled&#39;, int(self.__temperatureEnable), 2)
    writeData(f, &#39;TempAmplitude&#39;, self.__temperatureVaryAmplitude, 2)
    writeData(f, &#39;TempBase&#39;, self.__temperatureBaseValue, 2)
    writeData(f, &#39;VaryTempEnabled&#39;, int(self.__temperatureVaryEnable), 2)
    writeData(f, &#39;TempPeriod&#39;, self.__temperatureVaryPeriod, 2)
    writeData(f, &#39;TempOffset&#39;, self.__temperatureVaryOffset, 2)
    writeClos(f, &#39;Thermal&#39;, 1)

    writeData(f, &#39;GrowthAmplitude&#39;, self.__growthAmplitude, 1)
    writeClos(f, &#39;Environment&#39;, 0)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.writeSensors"><code class="name flex">
<span>def <span class="ident">writeSensors</span></span>(<span>self, f:Â <classÂ 'TextIO'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Write voxel sensors to a text file using the .vxa format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File to write to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeSensors(self, f: TextIO):
    &#34;&#34;&#34;
    Write voxel sensors to a text file using the .vxa format.

    Args:
        f: File to write to
    
    Returns:
        None
    &#34;&#34;&#34;
    writeOpen(f, &#39;Sensors&#39;, 0)
    for sensor in self.__sensors:
        writeOpen(f, &#39;Sensor&#39;, 1)
        if sensor.name is not None:
            writeData(f, &#39;Name&#39;, sensor.name, 2)
        writeData(f, &#39;Location&#39;, str(sensor.coords).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 2)
        writeData(f, &#39;Axis&#39;, sensor.axis.value, 2)
        writeClos(f, &#39;Sensor&#39;, 1)
    writeClos(f, &#39;Sensors&#39;, 0)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.writeSimData"><code class="name flex">
<span>def <span class="ident">writeSimData</span></span>(<span>self, f:Â <classÂ 'TextIO'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Write simulation parameters to a text file using the .vxa format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File to write to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeSimData(self, f: TextIO):
    &#34;&#34;&#34;
    Write simulation parameters to a text file using the .vxa format.

    Args:
        f: File to write to
    
    Returns:
        None
    &#34;&#34;&#34;
    # Simulator settings
    writeOpen(f, &#39;Simulator&#39;, 0)
    writeOpen(f, &#39;Integration&#39;, 1)
    writeData(f, &#39;Integrator&#39;, self.__integrator, 2)
    writeData(f, &#39;DtFrac&#39;, self.__dtFraction, 2)
    writeClos(f, &#39;Integration&#39;, 1)

    writeOpen(f, &#39;Damping&#39;, 1)
    writeData(f, &#39;BondDampingZ&#39;, self.__dampingBond, 2)
    writeData(f, &#39;ColDampingZ&#39;, self.__collisionDamping, 2)
    writeData(f, &#39;SlowDampingZ&#39;, self.__dampingEnvironment, 2)
    writeClos(f, &#39;Damping&#39;, 1)

    writeOpen(f, &#39;Collisions&#39;, 1)
    writeData(f, &#39;SelfColEnabled&#39;, int(self.__collisionEnable), 2)
    writeData(f, &#39;ColSystem&#39;, self.__collisionSystem, 2)
    writeData(f, &#39;CollisionHorizon&#39;, self.__collisionHorizon, 2)
    writeClos(f, &#39;Collisions&#39;, 1)

    writeOpen(f, &#39;Features&#39;, 1)
    writeData(f, &#39;BlendingEnabled&#39;, int(self.__blendingEnable), 2)
    writeData(f, &#39;XMixRadius&#39;, self.__xMixRadius, 2)
    writeData(f, &#39;YMixRadius&#39;, self.__yMixRadius, 2)
    writeData(f, &#39;ZMixRadius&#39;, self.__zMixRadius, 2)
    writeData(f, &#39;BlendModel&#39;, self.__blendingModel, 2)
    writeData(f, &#39;PolyExp&#39;, self.__polyExp, 2)
    writeData(f, &#39;VolumeEffectsEnabled&#39;, int(self.__volumeEffectsEnable), 2)
    writeClos(f, &#39;Features&#39;, 1)

    writeOpen(f, &#39;StopCondition&#39;, 1)
    writeData(f, &#39;StopConditionType&#39;, self.__stopConditionType.value, 2)
    writeData(f, &#39;StopConditionValue&#39;, self.__stopConditionValue, 2)
    writeClos(f, &#39;StopCondition&#39;, 1)

    writeOpen(f, &#39;EquilibriumMode&#39;, 1)
    writeData(f, &#39;EquilibriumModeEnabled&#39;, int(self.__equilibriumModeEnable), 2)
    writeClos(f, &#39;EquilibriumMode&#39;, 1)
    writeClos(f, &#39;Simulator&#39;, 0)</code></pre>
</details>
</dd>
<dt id="voxelfuse.simulation.Simulation.writeTempControls"><code class="name flex">
<span>def <span class="ident">writeTempControls</span></span>(<span>self, f:Â <classÂ 'TextIO'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Write temperature control element to a text file using the .vxa format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong></dt>
<dd>File to write to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeTempControls(self, f: TextIO):
    &#34;&#34;&#34;
    Write temperature control element to a text file using the .vxa format.

    Args:
        f: File to write to
    
    Returns:
        None
    &#34;&#34;&#34;
    writeData(f, &#39;EnableHydrogelModel&#39;, int(self.__hydrogelModelEnable), 0)

    writeOpen(f, &#39;TempControls&#39;, 0)
    for group in self.__localTempControls:
        writeOpen(f, &#39;Element&#39;, 1)

        if group.name is not None:
            writeData(f, &#39;Name&#39;, group.name, 2)

        writeOpen(f, &#39;Locations&#39;, 2)
        for loc in group.locations:
            writeData(f, &#39;Location&#39;, str(loc).replace(&#39;(&#39;, &#39;&#39;).replace(&#39;,&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;), 3)
        writeClos(f, &#39;Locations&#39;, 2)

        writeOpen(f, &#39;Keyframes&#39;, 2)
        for keyframe in group.keyframes:
            writeOpen(f, &#39;Keyframe&#39;, 3)
            writeData(f, &#39;TimeValue&#39;, keyframe.time_value, 4)
            writeData(f, &#39;AmplitudePos&#39;, keyframe.amplitude_pos, 4)
            writeData(f, &#39;AmplitudeNeg&#39;, keyframe.amplitude_neg, 4)
            writeData(f, &#39;PercentPos&#39;, keyframe.percent_pos, 4)
            writeData(f, &#39;Period&#39;, keyframe.period, 4)
            writeData(f, &#39;PhaseOffset&#39;, keyframe.phase_offset, 4)
            writeData(f, &#39;TempOffset&#39;, keyframe.temp_offset, 4)
            writeData(f, &#39;ConstantTemp&#39;, int(keyframe.const_temp), 4)
            writeData(f, &#39;SquareWave&#39;, int(keyframe.square_wave), 4)
            writeClos(f, &#39;Keyframe&#39;, 3)
        writeClos(f, &#39;Keyframes&#39;, 2)

        writeClos(f, &#39;Element&#39;, 1)
    writeClos(f, &#39;TempControls&#39;, 0)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="voxelfuse.simulation.StopCondition"><code class="flex name class">
<span>class <span class="ident">StopCondition</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for simulation stop conditions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StopCondition(Enum):
    &#34;&#34;&#34;
    Options for simulation stop conditions.
    &#34;&#34;&#34;
    NONE = 0
    TIME_STEP = 1
    TIME_VALUE = 2
    TEMP_CYCLES = 3
    ENERGY_CONST = 4
    ENERGY_KFLOOR = 5
    MOTION_FLOOR = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="voxelfuse.simulation.StopCondition.ENERGY_CONST"><code class="name">var <span class="ident">ENERGY_CONST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.StopCondition.ENERGY_KFLOOR"><code class="name">var <span class="ident">ENERGY_KFLOOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.StopCondition.MOTION_FLOOR"><code class="name">var <span class="ident">MOTION_FLOOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.StopCondition.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.StopCondition.TEMP_CYCLES"><code class="name">var <span class="ident">TEMP_CYCLES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.StopCondition.TIME_STEP"><code class="name">var <span class="ident">TIME_STEP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="voxelfuse.simulation.StopCondition.TIME_VALUE"><code class="name">var <span class="ident">TIME_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="voxelfuse" href="index.html">voxelfuse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="voxelfuse.simulation.poolInit" href="#voxelfuse.simulation.poolInit">poolInit</a></code></li>
<li><code><a title="voxelfuse.simulation.simProcess" href="#voxelfuse.simulation.simProcess">simProcess</a></code></li>
<li><code><a title="voxelfuse.simulation.simProcessLog" href="#voxelfuse.simulation.simProcessLog">simProcessLog</a></code></li>
<li><code><a title="voxelfuse.simulation.simProcessLogFine" href="#voxelfuse.simulation.simProcessLogFine">simProcessLogFine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="voxelfuse.simulation.Axis" href="#voxelfuse.simulation.Axis">Axis</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.simulation.Axis.NONE" href="#voxelfuse.simulation.Axis.NONE">NONE</a></code></li>
<li><code><a title="voxelfuse.simulation.Axis.X" href="#voxelfuse.simulation.Axis.X">X</a></code></li>
<li><code><a title="voxelfuse.simulation.Axis.Y" href="#voxelfuse.simulation.Axis.Y">Y</a></code></li>
<li><code><a title="voxelfuse.simulation.Axis.Z" href="#voxelfuse.simulation.Axis.Z">Z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.simulation.BCShape" href="#voxelfuse.simulation.BCShape">BCShape</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.simulation.BCShape.BOX" href="#voxelfuse.simulation.BCShape.BOX">BOX</a></code></li>
<li><code><a title="voxelfuse.simulation.BCShape.CYLINDER" href="#voxelfuse.simulation.BCShape.CYLINDER">CYLINDER</a></code></li>
<li><code><a title="voxelfuse.simulation.BCShape.SPHERE" href="#voxelfuse.simulation.BCShape.SPHERE">SPHERE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.simulation.MultiSimulation" href="#voxelfuse.simulation.MultiSimulation">MultiSimulation</a></code></h4>
<ul class="two-column">
<li><code><a title="voxelfuse.simulation.MultiSimulation.confirmSimCount" href="#voxelfuse.simulation.MultiSimulation.confirmSimCount">confirmSimCount</a></code></li>
<li><code><a title="voxelfuse.simulation.MultiSimulation.export" href="#voxelfuse.simulation.MultiSimulation.export">export</a></code></li>
<li><code><a title="voxelfuse.simulation.MultiSimulation.exportVXA" href="#voxelfuse.simulation.MultiSimulation.exportVXA">exportVXA</a></code></li>
<li><code><a title="voxelfuse.simulation.MultiSimulation.getParams" href="#voxelfuse.simulation.MultiSimulation.getParams">getParams</a></code></li>
<li><code><a title="voxelfuse.simulation.MultiSimulation.run" href="#voxelfuse.simulation.MultiSimulation.run">run</a></code></li>
<li><code><a title="voxelfuse.simulation.MultiSimulation.setParams" href="#voxelfuse.simulation.MultiSimulation.setParams">setParams</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.simulation.Simulation" href="#voxelfuse.simulation.Simulation">Simulation</a></code></h4>
<ul class="">
<li><code><a title="voxelfuse.simulation.Simulation.addBoundaryConditionBox" href="#voxelfuse.simulation.Simulation.addBoundaryConditionBox">addBoundaryConditionBox</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.addBoundaryConditionCylinder" href="#voxelfuse.simulation.Simulation.addBoundaryConditionCylinder">addBoundaryConditionCylinder</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.addBoundaryConditionSphere" href="#voxelfuse.simulation.Simulation.addBoundaryConditionSphere">addBoundaryConditionSphere</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.addBoundaryConditionVoxel" href="#voxelfuse.simulation.Simulation.addBoundaryConditionVoxel">addBoundaryConditionVoxel</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.addDisconnection" href="#voxelfuse.simulation.Simulation.addDisconnection">addDisconnection</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.addKeyframe" href="#voxelfuse.simulation.Simulation.addKeyframe">addKeyframe</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.addSensor" href="#voxelfuse.simulation.Simulation.addSensor">addSensor</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.addTempControlGroup" href="#voxelfuse.simulation.Simulation.addTempControlGroup">addTempControlGroup</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.applyTempMap" href="#voxelfuse.simulation.Simulation.applyTempMap">applyTempMap</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.cleanTempControlGroups" href="#voxelfuse.simulation.Simulation.cleanTempControlGroups">cleanTempControlGroups</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.clearBoundaryConditions" href="#voxelfuse.simulation.Simulation.clearBoundaryConditions">clearBoundaryConditions</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.clearDisconnections" href="#voxelfuse.simulation.Simulation.clearDisconnections">clearDisconnections</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.clearKeyframes" href="#voxelfuse.simulation.Simulation.clearKeyframes">clearKeyframes</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.clearSensors" href="#voxelfuse.simulation.Simulation.clearSensors">clearSensors</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.clearTempControlGroups" href="#voxelfuse.simulation.Simulation.clearTempControlGroups">clearTempControlGroups</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.copy" href="#voxelfuse.simulation.Simulation.copy">copy</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getCollision" href="#voxelfuse.simulation.Simulation.getCollision">getCollision</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getDamping" href="#voxelfuse.simulation.Simulation.getDamping">getDamping</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getEquilibriumMode" href="#voxelfuse.simulation.Simulation.getEquilibriumMode">getEquilibriumMode</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getGravity" href="#voxelfuse.simulation.Simulation.getGravity">getGravity</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getHydrogelModel" href="#voxelfuse.simulation.Simulation.getHydrogelModel">getHydrogelModel</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getModel" href="#voxelfuse.simulation.Simulation.getModel">getModel</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getStopCondition" href="#voxelfuse.simulation.Simulation.getStopCondition">getStopCondition</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getThermal" href="#voxelfuse.simulation.Simulation.getThermal">getThermal</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.getVoxelDim" href="#voxelfuse.simulation.Simulation.getVoxelDim">getVoxelDim</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.initializeTempMap" href="#voxelfuse.simulation.Simulation.initializeTempMap">initializeTempMap</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.removeTempControlGroup" href="#voxelfuse.simulation.Simulation.removeTempControlGroup">removeTempControlGroup</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.runSim" href="#voxelfuse.simulation.Simulation.runSim">runSim</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.runSimVoxCad" href="#voxelfuse.simulation.Simulation.runSimVoxCad">runSimVoxCad</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.saveResults" href="#voxelfuse.simulation.Simulation.saveResults">saveResults</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.saveVXA" href="#voxelfuse.simulation.Simulation.saveVXA">saveVXA</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.selectTempControlGroup" href="#voxelfuse.simulation.Simulation.selectTempControlGroup">selectTempControlGroup</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setCollision" href="#voxelfuse.simulation.Simulation.setCollision">setCollision</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setDamping" href="#voxelfuse.simulation.Simulation.setDamping">setDamping</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setEquilibriumMode" href="#voxelfuse.simulation.Simulation.setEquilibriumMode">setEquilibriumMode</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setFixedThermal" href="#voxelfuse.simulation.Simulation.setFixedThermal">setFixedThermal</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setGravity" href="#voxelfuse.simulation.Simulation.setGravity">setGravity</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setHydrogelModel" href="#voxelfuse.simulation.Simulation.setHydrogelModel">setHydrogelModel</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setModel" href="#voxelfuse.simulation.Simulation.setModel">setModel</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setStopCondition" href="#voxelfuse.simulation.Simulation.setStopCondition">setStopCondition</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.setVaryingThermal" href="#voxelfuse.simulation.Simulation.setVaryingThermal">setVaryingThermal</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.writeDisconnections" href="#voxelfuse.simulation.Simulation.writeDisconnections">writeDisconnections</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.writeEnvironmentData" href="#voxelfuse.simulation.Simulation.writeEnvironmentData">writeEnvironmentData</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.writeSensors" href="#voxelfuse.simulation.Simulation.writeSensors">writeSensors</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.writeSimData" href="#voxelfuse.simulation.Simulation.writeSimData">writeSimData</a></code></li>
<li><code><a title="voxelfuse.simulation.Simulation.writeTempControls" href="#voxelfuse.simulation.Simulation.writeTempControls">writeTempControls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="voxelfuse.simulation.StopCondition" href="#voxelfuse.simulation.StopCondition">StopCondition</a></code></h4>
<ul class="two-column">
<li><code><a title="voxelfuse.simulation.StopCondition.ENERGY_CONST" href="#voxelfuse.simulation.StopCondition.ENERGY_CONST">ENERGY_CONST</a></code></li>
<li><code><a title="voxelfuse.simulation.StopCondition.ENERGY_KFLOOR" href="#voxelfuse.simulation.StopCondition.ENERGY_KFLOOR">ENERGY_KFLOOR</a></code></li>
<li><code><a title="voxelfuse.simulation.StopCondition.MOTION_FLOOR" href="#voxelfuse.simulation.StopCondition.MOTION_FLOOR">MOTION_FLOOR</a></code></li>
<li><code><a title="voxelfuse.simulation.StopCondition.NONE" href="#voxelfuse.simulation.StopCondition.NONE">NONE</a></code></li>
<li><code><a title="voxelfuse.simulation.StopCondition.TEMP_CYCLES" href="#voxelfuse.simulation.StopCondition.TEMP_CYCLES">TEMP_CYCLES</a></code></li>
<li><code><a title="voxelfuse.simulation.StopCondition.TIME_STEP" href="#voxelfuse.simulation.StopCondition.TIME_STEP">TIME_STEP</a></code></li>
<li><code><a title="voxelfuse.simulation.StopCondition.TIME_VALUE" href="#voxelfuse.simulation.StopCondition.TIME_VALUE">TIME_VALUE</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>